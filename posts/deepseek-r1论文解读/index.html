<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DeepSeek R1论文解读 | Huaipeng's Blog</title><meta name=keywords content><meta name=description content='1. 背景
春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的"ChatGPT时刻"。R1模型是DeepSeek一年来持续探索与积累的成果，体现了算法、架构与硬件的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。'><meta name=author content="Huaipeng Zhao"><link rel=canonical href=https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://hpzhao.github.io/img/logo.gif><link rel=icon type=image/png sizes=16x16 href=https://hpzhao.github.io/img/logo.gif><link rel=icon type=image/png sizes=32x32 href=https://hpzhao.github.io/img/logo.gif><link rel=apple-touch-icon href=https://hpzhao.github.io/logo.gif><link rel=mask-icon href=https://hpzhao.github.io/logo.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"><meta property="og:site_name" content="Huaipeng's Blog"><meta property="og:title" content="DeepSeek R1论文解读"><meta property="og:description" content='1. 背景 春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的"ChatGPT时刻"。R1模型是DeepSeek一年来持续探索与积累的成果，体现了算法、架构与硬件的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T00:41:49+08:00"><meta property="article:modified_time" content="2025-02-24T00:41:49+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="DeepSeek R1论文解读"><meta name=twitter:description content='1. 背景
春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的"ChatGPT时刻"。R1模型是DeepSeek一年来持续探索与积累的成果，体现了算法、架构与硬件的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hpzhao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DeepSeek R1论文解读","item":"https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DeepSeek R1论文解读","name":"DeepSeek R1论文解读","description":"1. 背景 春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的\u0026quot;ChatGPT时刻\u0026quot;。R1模型是DeepSeek一年来持续探索与积累的成果，体现了算法、架构与硬件的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。\n","keywords":[],"articleBody":"1. 背景 春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的\"ChatGPT时刻\"。R1模型是DeepSeek一年来持续探索与积累的成果，体现了算法、架构与硬件的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。\n2. 性能与成本 2.1. 评估数据集 MMLU(Massive Multitask Language Understanding)：[Paper] [Dataset Card] 这是一项大规模的多任务测试，包含来自不同知识领域的选择题。测试涵盖人文学科、社会科学、自然科学以及其他一些对某些人来说重要的学习领域。这包括57个任务，如基础数学、美国历史、计算机科学、法律等。要想在这一测试中取得高准确率，模型必须具备广泛的世界知识和强大的问题解决能力。\nMMLU-Pro： MMLU-Pro数据集是一个更加稳健且富有挑战性的大规模多任务理解数据集，旨在更严格地评估大型语言模型的能力。该数据集涵盖了多个学科的12,000道复杂问题。主要有三项改进：首先，将选项数量从4个增加至10个，提升了评估的真实性和挑战性，显著降低了随机猜测的得分；其次，提高了问题难度，增加更多推理型问题，使得CoT的结果可能比PPL高出20%；最后，通过增加干扰项，降低随机猜测概率，增强了基准测试的鲁棒性，模型得分对提示变化的敏感性从4-5%降至2%。\nGPQA：[Paper] [Dataset Card] GPQA包含了448道由生物学、物理学和化学领域的专家编写的多项选择题。我们确保这些问题的质量高且极具难度：在相应领域拥有或正在攻读博士学位的专家答题准确率为65%（在排除专家事后发现的明显错误后，准确率上升至74%），而技能高超的非专家验证者尽管平均花费超过30分钟并拥有无限制的网络访问权限（即问题\"防谷歌\"），准确率仅为34%。这些问题对于最先进的AI系统同样困难，我们基于GPT-4的最强基线模型准确率仅为39%。\nMATH 500：[Paper] [Dataset Card] 这个数据集包含了来自OpenAI在其论文《Let’s Verify Step by Step》中创建的MATH基准测试的500道题目子集。\nAIME 2024：[Dataset Card] 该数据集包含了2024年AIME I和AIME II测试中的30道题目。\nCodeforces：[Source] 编程试题。\nSWE-bench：[Dataset Card] SWE-bench 是一个用于测试系统自动解决 GitHub 问题能力的数据集。该数据集收集了来自 12 个热门 Python 仓库的 2,294 个\"问题-拉取请求\"对。评估通过单元测试验证进行，并以拉取请求后的行为作为参考解决方案。\n2.2. 评估结果 2.3. 训练与推理成本 训练成本：Llama3-405B使用了30.8M GPU时，而DeepSeek-V3 性能更强，仅使用了2.8M GPU时（计算量减少了约 11 倍）。\nChat类模型推断价格对比：\nReasoner类模型推断价格对比：\ninput (Price/1M) Cached input (Price/1M) Output (Price/1M) OpenAI o1 $15.0 $7.5 $60.0 OpenAI o3-mini $1.1 $0.55 $4.4 DeepSeek R1 $0.55 $0.14 $2.19 3. 模型架构 DeepSeek主打的卖点是计算开销低，从架构上主要通过MLA和MOE两个模块实现。\n3.1. MOE MOE(Mixture of Expert)自Google提出以来便应用到多个领域，包括NLP、多模态、视觉和推荐系统中。大语言模型参数量与性能有密切关系，但参数量增大也会带来训练和推断成本的上升。MOE是一种在扩大模型参数时管理计算成本的非常有效的架构。\nMOE可以分为Dense MoE和Sparse MoE两种类型。Dense MoE的特征在于所有专家都会被激活，只是每个专家承担的权重不同，可以理解为一种加权投票机制，每个专家负责不同的能力。然而，这种架构并不能减少计算量。相较之下，Sparse MoE只选择性激活TopK个专家，从而显著降低计算量。因此，DeepSeek选择采用Sparse MoE架构。\n在DeepSeekMoE模型中，相较于传统的Naive Sparse MoE，有两项主要改进。首先，DeepSeekMoE将专家（Expert）的数量增加了一倍，这样每个专家可以学习到更加差异化的知识。其次，模型引入了共享专家（Shared Expert）。在传统的路由策略中，被分配给不同专家的token可能共享某些知识或信息。因此，不同专家可能在各自的参数中包含相同的知识，这导致参数的冗余。通过引入专门用于捕获和整合这些共同知识的共享专家，可以有效地缓解路由专家之间存在的参数冗余问题。\n自动学习到的路由策略可能会遇到负载不均衡(load imbalance)的问题，这表现为两个显著的缺陷。首先，存在路由崩溃的风险，即模型总是只选择少数专家，导致其他专家无法得到充分的训练。其次，如果专家分布在多个设备上，负载不均衡会加剧计算瓶颈。\n解决负载均衡常用的方法是Switch Transformer中提出的辅助Loss：\n$f_i$即真实分配给expert $i$ 的概率，$P_i$ 为模型计算的分配给expert $i$ 的概率。文中认为loss会在 $f$ 和 $P$ 都是均匀分布时最小，此时每个专家被分配的概率都是相等的。例如有两个专家，那么loss的值为[0.5,0.5] * [0.5,0.5] = 0.5。但是这个结论是错误的：\n另外从直觉上，最小化这个loss意味着最小化 $\\langle f, P \\rangle$，而内积代表了相关性，这也并不合理。除此之外，这个辅助Loss只是想在expert之间做负载均衡，loss过大也会影响模型效果。\nDeepSeek提出Loss Free的方法来解决负载不均衡的问题。在计算gate softmax时考虑此时每个expert的分配情况，从而进行动态调整权重。\n3.2. MLA MLA(Multi-head Latent Attention)的核心思想是通过压缩KV，降低KV Cache存储压力，这是DeepSeek降本的核心设计之一。\nSelf Attention的核心思想是每个token的表示都是所有token的加权求和，权重即为token之间的correlation。每个Q、K、V都会被切成若干个head。\n$$ \\begin{aligned} \\mathbf{q}_t \u0026= W^Q \\mathbf{h}_t = [\\mathbf{q}_{t,1}; \\mathbf{q}_{t,2}; \\ldots; \\mathbf{q}_{t,n_h}], \\\\ \\mathbf{k}_t \u0026= W^K \\mathbf{h}_t = [\\mathbf{k}_{t,1}; \\mathbf{k}_{t,2}; \\ldots; \\mathbf{k}_{t,n_h}], \\\\ \\mathbf{v}_t \u0026= W^V \\mathbf{h}_t = [\\mathbf{v}_{t,1}; \\mathbf{v}_{t,2}; \\ldots; \\mathbf{v}_{t,n_h}], \\\\ \\mathbf{o}_{t,i} \u0026= \\sum_{j=1}^{t} \\text{Softmax}_j \\left( \\frac{\\mathbf{q}_{t,i}^T \\mathbf{k}_{j,i}}{\\sqrt{d_h}} \\right) \\mathbf{v}_{j,i}, \\\\ \\mathbf{u}_t \u0026= W^O [\\mathbf{o}_{t,1}; \\mathbf{o}_{t,2}; \\ldots; \\mathbf{o}_{t,n_h}], \\end{aligned} $$主流的LLM均为Casual Decoder架构，每个token只能看到前序的token，不能看到后面的token。如果每个token生成时都重新计算前序所有token的KV会产生大量的冗余计算。因此可以把之前计算好的KV缓存下来，以空间换时间，这就是所谓的KV Cache。\n当token数较多时也会带来性能瓶颈，因此产生了GQA和MQA这种工作。\nMLA核心思路是将KV映射到一个语义空间，需要的时候再进行还原，这样大大降低了Cache大小。\n另外在推断的时候，$W^{UK}$ 能被吸收到 $W^Q$ 中，$W^{UV}$ 能被吸收到 $W^O$ 中，因此并不需要按公式还原出 $K$ 和 $V$，这也意味着计算也是在Latent Space的，和Stable Diffusion等工作的思路很相似。我们以 $W^{UK}$ 为例，计算分数时：\n$$ q^T k = (W^Q h)^T (W^{UK} c^{KV}) = h^T [(W^Q)^T W^{UK}] c^{KV} = h^T W^Q_{new} c^{KV} $$在上述计算过程中，位置向量未被考虑。Transformer中的位置编码通常分为三类：1）绝对位置编码：为每个位置分配一个可训练或固定的位置向量，应用到token embedding上。其优点在于简单实现，但缺点在于扩展性差，并且不包含相对位置信息。例如，位置0和位置1之间的差异无法与位置1和位置200之间的差异呈现实际对比。2）相对位置编码：应用到查询（Q）和键（K）上，具有较好的扩展性。然而，计算开销较大，并且不适用于KV Cache架构。3）旋转位置编码（RoPE）：结合了绝对和相对位置编码的优点。通过向量旋转的方式，旋转角度与绝对位置线性相关，同时在QK计算中能够体现相对位置信息。\n然而将RoPE直接应用到MLA中会导致 $W^{UK}$ 不能被吸收到 $W^Q$ 中，导致MLA的计算开销增大。具体来说：\n$$ \\begin{aligned} \\text{RoPE}(q_t)^T \\text{RoPE}(k_m) \u0026= (R^q_t q_t)^T (R^k_m k_m) \\\\ \u0026= q_t^T (R^q_t)^T R^k_m k_m \\\\ \u0026= (W^Q h_t)^T (R^q_t)^T R^k_m (W^{UK} c^{KV}_m) \\\\ \u0026= h_t^T (W^Q)^T \\overline{(R^q_t)^T R^k_m} W^{UK} c^{KV}_m \\end{aligned} $$中间的两个旋转矩阵是和位置相关的，因此 $W^{UK}$ 不能被吸收到 $W^Q$ 中，需要每次重新计算。论文提出使用额外的一些head计算位置向量，然后再拼到QK中。这意味着也要同时缓存 $k^R_t$。\n3.3. MTP DeepSeek MTP(Multi-Token Prediction)能够提升数据利用效率，也提升了模型的规划能力。主要受两篇工作启发得到，一是提升训练效率的Google MTP，二是提升推理效率的EAGLE。\n传统的语言模型（LLM）在训练时通常只关注于预测下一个可能的Token。这种方法存在两个明显的局限性。首先，由于训练的信号较弱，模型对那些在句子中起重要转折作用的词汇（Hard Transitions Token）往往关注不足。其次，这种逐词预测的方式缺乏全局的规划能力，而人类在组织语言时通常是以段落为单位进行构思，而不是逐词考虑。基于上述背景，Google提出MTP，把模型最后一层的Head进行分组，每一层分别预测不同位置的token。\n从结果上来看，引入MTP后模型效果得到明显提升。从分析上来看，模型增加了对hard transition token的训练信号。如下图所示，如果只预测next one，那么\"5-\u003eA\"的训练信号只有1/7=14%，而预测next three时，hard transition token占比为6/21=28%，可以看到训练信号大幅增加。但MTP训练时每个分组head都是独立的(parallel heads)，这违背了自回归的设计原则。\n另一篇借鉴的工作是大模型推理加速相关工作-Speculative Decoding.\nEAGLE是Speculative Decoding一篇知名工作，文中验证了Causal Heads优于Parallel Heads。因此deepseek将MTP中的Parallel Heads改成Causal Heads.\n4. 基础设施 4.1. 计算集群 DeepSeek-V3在配备有2048块NVIDIA H800 GPU的集群上进行训练。H800集群中的每个节点包含8块通过NVLink和NVSwitch连接的GPU。在不同节点之间，使用InfiniBand (IB)互连来实现通信。\n4.2. DualPipe 流水线并行是一种提高计算效率的方法，通过将任务分解为多个阶段，并在不同计算单元之间传输数据，从而实现多个任务的重叠执行。具体来说，流水线并行像工厂流水线一样，将一项任务分成多个连续的步骤，每个步骤由不同的计算单元（例如处理器或加速器）负责。这种并行化可以显著减少模型训练或推理的时间。模型做一轮forward和backward的过程如下，我们会发现后面层需要等前面的计算完才能开始计算，会导致GPU在一段时间是闲置的。空白部分所表示的时间段里，总有GPU在空转。在Gpipe中，将阴影部分定义为bubble。\n对于 DeepSeek-V3，由跨节点专家并行引入的通信开销导致计算与通信比率约为 1:1，这种情况效率较低。为了解决这一挑战，deepseek设计了一种创新的流水线并行算法，称为 DualPipe。该算法通过有效地重叠正向和反向的计算—通信阶段，加速了模型训练，并减少了流水线气泡。DualPipe 的核心理念是重叠单个正向和反向片段中的计算和通信。具体来说，我们将每个片段分为四个组成部分：注意力（attention）、全对全调度（all-to-all dispatch）、多层感知器（MLP）和全对全组合（all-to-all combine）。例如AB两个块，A块在前向计算时，B块做反向传播的通信，反之亦然。\n“全对全”(“all-to-all”)通常用于描述一种网络通信模式，其中每个节点都需要与系统中的其他所有节点进行数据交换。这种通信模式常用于分布式计算和并行计算框架中，以便协调多个计算节点之间的数据共享和同步。\n通过这种方式，大幅提高了GPU利用率：\n4.3. FP8 Training 通常我们训练神经网络模型的时候默认使用的数据类型为FP32，而混合精度训练是指在训练的过程中，同时使用FP32和低精度（FP16、FP8），从而在尽量保持模型精度持平的条件下，加快训练时间、减少训练时内存占用。Deepseek提出了一种用于FP8训练的混合精度框架。在这个框架中，大多数计算密集型操作在FP8中进行，而一些关键操作则战略性地保持其原始数据格式，以平衡训练效率和数值稳定性。模型效果损失能够稳定控制在**0.25%**以内。\n为了提升模型效果设计了两种优化手段：\n细粒度量化. 在低精度训练中，FP8格式因其有限的动态范围而面临溢出和下溢的问题。传统方法通过缩放输入张量来缓解，但对异常值敏感。为解决此问题，deepseek提出更细致的量化方法：对激活值以1x128的块缩放，对权重以128x128的块缩放。这种方法提高了量化过程对异常值的适应性。 提高累积精度. 低精度GEMM（广义矩阵乘法）操作常面临下溢问题，累加精度依赖高精度处理，通常是FP32。然而，在NVIDIA H800 GPU上的FP8 GEMM累加精度仅约14位，低于FP32。为解决此问题，我们建议将运算提升到CUDA核心，以实现更高精度。具体过程在Tensor核心上执行MMA时，使用有限位宽累加中间结果，达到𝑁𝐶间隔时，将部分结果复制到CUDA核心的FP32寄存器进行全精度FP32累加。 5. RL训练策略 预训练部分较为常规，我们重点关注R1涉及到的RL训练策略。\n5.1. O1引发的推理研究热潮 gpt-o1的推出引发了推理研究的热潮，研究重点为构造COT推理数据。奖励设计可分为结果监督(ORM)和过程监督(PRM)，另外也有研究基于搜索的方法，例如MCTS.\nORM的代表工作为StaR，提出自举式数据生成方案，大幅提升了模型推理能力。首先根据原始问题让大模型生成\u003c答案，推理\u003e对，对于答案生成正确的作为可用微调样本。对于错误答案的，根据答案提示让模型有更大概率生成更好的解释，然后用于训练中间模型。最终训练模型时，只利用能推理出正确答案的样本，对于不能生成正确答案的直接丢弃。方法有个明显缺陷是对于推理过程没有校验，即使答案正确推理也有可能是错误的，尤其是对于二元判别，生成数据噪声比较大。\nOpenAI在2023年的研究成果显示，通过过程监督训练出的奖励模型比结果监督更可靠。他们利用先进的过程监督方法解决了78.2%的MATH测试集问题，并证明大型奖励模型可以有效地指导小型奖励模型进行类似人类的监督，可用于高效的大规模数据收集。\n5.2. 从PPO到GRPO 强化学习是一种通过试错和从环境反馈中学习以优化序列决策问题的机器学习方法。游戏是一个典型的序列决策问题，玩家需要根据当前状态(State)做出决策(Action)，目标是获得游戏胜利(Reward)。强化学习的目标是最大化Expected Reward。\n策略梯度(Policy Gradient)是一个比较直观的方法，直接利用梯度上升来最大化期望Reward. 下面是一个示例，输入是游戏的一帧画面 $s^n_t$，然后利用神经网络进行表征学习，最后输出Action $a^n_t$。如果不考虑Reward，其优化目标就是一个的典型的分类问题。\n策略梯度有两个重要改进，一是考虑到有些场景reward都是正的，例如考试分数都会大于0，因此需要减去一个baseline让reward有正有负。二是对于一个采样而言，所有action都是利用相同的reward，即使最终游戏胜利，里面也会存在一些差的action，因此需要为每个action分配合理的reward，即在状态 $s$ 下采取 $a$ 的未来期望收益。改进后的这一项被称为优势函数 $A^\\theta(s_t, a_t)$，用来衡量状态 $s$ 下采取 $a$ 的相对优势。优势函数可以用值函数计算：$A^\\theta(s_t, a_t) = Q(s_t, a_t) - V^\\pi(s^n_t) = r^n_t + \\gamma V^\\pi(s^n_{t+1}) - V^\\pi(s^n_t)$。$r^n_t$ 指状态 $s_t$ 采取 $a_t$ 所获得的即时收益，$V^\\pi(s^n_t)$ 指在策略 $\\pi$ 下状态 $s_t$ 的未来期望收益。\n计算优势函数有两种方法，一种是Monte-Carlo (MC)，使用完整轨迹的奖励，缺点是方差很大，另一种是Temporal difference (TD)，即采用一步轨迹的奖励，缺点是偏差太大。为了综合上述两种方法，常采用General Advantage Estimation (GAE)，即多步TD加权求和：\n另一个要解决的问题是采样问题，回顾下PG目标 $\\nabla \\bar{R}_\\theta = E_{\\tau \\sim p_\\theta(\\tau)}[R(\\tau) \\nabla \\log p_\\theta(\\tau)]$，这里的采样 $\\tau$ 依赖要训练的策略网络 $\\pi_\\theta$。当 $\\theta$ 更新时，我们必须重新采样训练样本，这显然非常费时。因此我们想利用另一个策略 $\\pi'_\\theta$ 去采样多条数据，这样 $\\pi_\\theta$ 可以重复利用数据。这里利用了重要性采样公式：\n$$ E_{x \\sim p}[f(x)] = E_{x \\sim q}\\left[f(x) \\frac{p(x)}{q(x)}\\right] $$那么PG目标就变成：$\\nabla \\bar{R}_\\theta = E_{\\tau \\sim p_{\\theta'}(\\tau)}\\left[\\frac{p_\\theta(\\tau)}{p_{\\theta'}(\\tau)} R(\\tau) \\nabla \\log p_\\theta(\\tau)\\right]$。当采样网络 $\\pi'_\\theta$ 和策略网络 $\\pi_\\theta$ 分布差异太大会导致效果不好，而PPO提出将两个分布的差异建模到Loss中，$J^{\\theta^k}_{PPO}(\\theta) = J^{\\theta^k}(\\theta) - \\beta KL(\\theta, \\theta^k)$。PPO2更为简化：\n应用到LLM训练中，PPO的优化目标为：\n同时为了避免RL过度优化，导致模型通用能力退化，标准RLHF为每个token的reward增加了惩罚项，避免过度偏离参考模型：\n由于PPO中使用的价值函数通常是与策略模型规模相当的另一个模型，它带来了大量的内存和计算负担。此外，在强化学习训练中，价值函数被用作方差减少的基线。然而，在LLM的背景下，通常只有最后一个标记会被奖励模型赋予奖励分数，这可能使得训练一个在每个标记上都准确的价值函数变得复杂。为了解决这个问题，deepseek提出了GRPO(Group Relative Policy Optimization)，它避免了像PPO那样需要额外的价值函数近似，而是使用响应同一问题生成的多个采样输出的平均奖励作为基线。\nGRPO的优化目标如下：\nGRPO并没有在奖励中添加KL惩罚，而是通过将训练策略与参考策略之间的KL散度直接添加到损失中进行正则化，从而避免了复杂的 $\\hat{A}_{i,t}$ 的计算。\n对于结果监督的RL(REINFORCE)，优势函数计算如下：\n$$ \\hat{A}_{i,t} = \\tilde{r}_i = \\frac{r_i - \\text{mean}(\\mathbf{r})}{\\text{std}(\\mathbf{r})} $$对于过程监督的RL(Actor-Critic)，优势函数计算如下：\n$$ \\hat{A}_{i,t} = \\sum_{\\text{index}(j) \\geq t} \\tilde{r}^{\\text{index}(j)}_i, \\quad \\tilde{r}^{\\text{index}(j)}_i = \\frac{r^{\\text{index}(j)}_i - \\text{mean}(\\mathbf{R})}{\\text{std}(\\mathbf{R})} $$$$ \\mathbf{R} = \\{\\{r^{\\text{index}(1)}_1, \\ldots, r^{\\text{index}(K_1)}_1\\}, \\ldots, \\{r^{\\text{index}(1)}_G, \\ldots, r^{\\text{index}(K_G)}_G\\}\\} $$论文还验证了一个被广泛流传但未经充分验证的观点：代码训练可以提高推理能力。\n作者将SFT, RFT, DPO, PPO, GRPO抽象为统一的范式：\n这里有三个关键组件：1）数据源 $\\mathcal{D}$，决定训练数据；2）奖励函数 $\\pi_{rf}$，训练奖励信号的来源；3）算法 $\\mathcal{A}$：处理训练数据和奖励信号以获得梯度系数 $GC$，确定对数据进行惩罚或强化的幅度。\n通过实验有两个观察：\n数据源分为在线采样和离线采样，前者使用实时策略模型的采样结果，后者依赖初始SFT模型。观察表明，Online RFT在基准测试中明显优于RFT，特别是在训练后期，因为来自actor的采样数据表现出更显著的差异，实时数据采样带来了明显优势。 奖励函数被分为\"规则\"和\"模型\"两部分，其中\"规则\"评估答案正确性，而\"模型\"使用奖励模型对响应评分。GRPO和Online RFT的主要区别在于：GRPO根据奖励模型的奖励值调整梯度系数，能够区分强化和惩罚不同程度的响应，而Online RFT缺少这一特征，对所有正确的响应以相同强度进行强化。 关于RL为什么有效，文章给出一个较为有趣的观察。通过评估Instruct和RL模型，发现RL提升了Maj@K的表现，但没有提升Pass@K。这些发现表明，RL通过使输出分布更加稳健来增强模型的整体性能，换句话说，这种改进似乎是由于提升了TopK中的正确响应，而不是增强了基本能力。\n5.3. R1-Zero训练策略 R1-Zero不依赖监督数据，仅靠RL自驱学习就能达到很好的推理性能。R1-Zero用的强化学习算法就是上节的GRPO。设计了两个规则式Reward：\n准确性奖励：准确性奖励模型评估响应是否正确。例如，对于具有确定性结果的数学问题，模型需要以指定格式（例如，在框内）提供最终答案，从而实现可靠的基于规则的正确性验证。同样，对于 LeetCode 问题，可以使用编译器根据预定义的测试用例生成反馈。 格式奖励：除了准确性奖励模型之外，我们还采用了一种格式奖励模型，要求模型将其思维过程置于 ‘’ 和 ‘’ 标签之间。 用到的训练模板如下：\n仅仅如此简洁的设计，在推理Benchmark上就达到了很高的水准：\nDeepSeek-R1-Zero在整个训练过程中，其思考时间呈现出持续的改进。这一进步并不是外部调整的结果，而是模型内部本质上的发展。DeepSeek-R1-Zero通过利用延长的测试时间计算，自然获得了解决越来越复杂推理任务的能力。这种计算涉及生成数百到数千个推理标记，使得模型能够以更深入的方式探索和完善其思维过程。\n在DeepSeek-R1-Zero的训练过程中，观察到一个特别有趣的现象，即出现了**“顿悟时刻”(aha moment)**。这一时刻发生在模型的中间版本。在这个阶段，DeepSeek-R1-Zero通过重新评估其初始方法，学会将更多的思考时间分配给一个问题。此行为不仅证明了模型日益增强的推理能力，也是强化学习如何引导出意外且复杂结果的一个引人入胜的例子。已经有多个工作能够复现\"aha moment\"。\n5.4. R1训练策略 尽管DeepSeek-R1-Zero表现出强大的推理能力，并能自主发展出意想不到的强大推理行为，但它仍面临一些问题。例如，DeepSeek-R1-Zero在可读性较差和语言混合等方面遇到挑战。为了使推理过程更加可读，R1训练结合了少量冷启动数据。该流程分为四个阶段：\n冷启动. 一开始要收集少量的Long-CoT数据来微调模型，目的是防止早期训练不稳定和可读性差问题。\n推理导向的RL. 在对DeepSeek-V3-Base进行冷启动数据的微调后，采用与DeepSeek-R1-Zero相同的大规模强化学习训练过程。这一阶段的重点是提高模型的推理能力，尤其是在编码、数学、科学和逻辑推理等。为了缓解语言混合的问题，在RL训练中引入了语言一致性奖励，该奖励是根据CoT中目标语言单词的比例来计算的。虽然消融实验表明这种对齐会导致模型性能略有下降，但这一奖励符合人类偏好，使其更加易读。最后，通过直接相加推理任务的准确性和语言一致性奖励来形成最终奖励。然后对微调后的模型进行RL训练，直到在推理任务上达到收敛。\n拒绝采样和SFT. 当面向推理的强化学习（RL）收敛之后，我们利用得到的检查点来收集用于下一轮的有监督微调（SFT）数据。与最初的冷启动数据主要关注推理不同，此阶段结合了来自其他领域的数据，以增强模型在写作、角色扮演和其他通用任务方面的能力。具体来说，按照以下步骤生成800K训练数据，并对DeepSeek-V3-Base进行了两轮的微调。\n推理数据. 编写了推理提示，通过拒绝采样从RL训练的检查点中生成推理轨迹。在前一个阶段，数据集中仅包含可以通过基于规则的奖励进行评估的数据。而在这一阶段，数据集得到了扩展，包含了一些使用生成式奖励模型产生的数据。此外，由于模型输出有时可能会显得冗长或难以理解，特意去除掉了混合语言、长段落及代码块中的链式思维。对于每个提示，生成了多个响应，但只保留了那些正确的版本。在整个过程中，收集了约60万条与推理相关的训练样本。\n非推理数据. 对于不涉及推理的数据类型，包括写作、事实问答、自我认知和翻译，采用了DeepSeek-V3流程，同时重用了部分DeepSeek-V3的SFT数据集。在某些非推理任务中，通过提示在回答问题前调用DeepSeek-V3生成潜在的链式思维。但对于诸如\"hello\"这类简单的查询，则不提供链式思维作为回应。最终，收集了大约20万条与推理无关的训练样本。\n面向所有领域的RL. 在第3阶段微调模型的基础上，进一步提升模型的有用性和无害性，同时改进其推理能力。对于推理任务，采用规则的奖励来指导。对于一般任务，采用奖励模型来对齐人类偏好。\n蒸馏实验有两个发现，一是通过大模型蒸馏能够大幅提升小模型能力；二是小模型直接RL训练的效果不如蒸馏效果，这也反映了训练更大模型的必要性。\n文章最后也提到了尝试PRM和MCTS的失败经历，探讨了这两种方法的弊端。\n6. 参考文献 DeepSeek LLM: Scaling Open-Source Language Models with Longtermism DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model DeepSeek-V3 Technical Report DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning DeepSeek分析-Semianalysis A Survey on Mixture of Experts Switch Transformers Switch Transformers课程 Auxiliary-Loss-Free Load Balancing Strategy for Mixture-of-Experts RoFormer: Enhanced Transformer with Rotary Position Embedding Understanding Rotary Positional Encoding Better \u0026 Faster Large Language Models via Multi-token Prediction Fast Inference from Transformers via Speculative Decoding KOALA: Enhancing Speculative Decoding for LLM via Multi-Layer Draft Heads with Adversarial Learning EAGLE: Speculative Sampling Requires Rethinking Feature Uncertainty MEDUSA: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads Introducing GPipe DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models Proximal Policy Optimization Algorithms Deep Reinforcement Learning, 2018 PPO原理与源码解读 DeepSeek V3解读 STaR: Self-Taught Reasoner Bootstrapping Reasoning With Reasoning Let’s Verify Step by Step 如何评价deepseek-R1与deepseek-R1-Zero模型？ Evaluating Security Risk in DeepSeek How Far Are We From AGI: Are LLMs All We Need? ","wordCount":"10099","inLanguage":"en","datePublished":"2025-02-24T00:41:49+08:00","dateModified":"2025-02-24T00:41:49+08:00","author":[{"@type":"Person","name":"Huaipeng Zhao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"},"publisher":{"@type":"Organization","name":"Huaipeng's Blog","logo":{"@type":"ImageObject","url":"https://hpzhao.github.io/img/logo.gif"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hpzhao.github.io/ accesskey=h title="Huaipeng's Blog (Alt + H)">Huaipeng's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hpzhao.github.io/ title=Posts><span>Posts</span></a></li><li><a href=https://hpzhao.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://hpzhao.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://hpzhao.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://hpzhao.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hpzhao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hpzhao.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DeepSeek R1论文解读</h1><div class=post-meta><span title='2025-02-24 00:41:49 +0800 +0800'>2025-02-24</span>&nbsp;·&nbsp;<span>21 min</span>&nbsp;·&nbsp;<span>Huaipeng Zhao</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e8%83%8c%e6%99%af aria-label="1. 背景">1. 背景</a></li><li><a href=#2-%e6%80%a7%e8%83%bd%e4%b8%8e%e6%88%90%e6%9c%ac aria-label="2. 性能与成本">2. 性能与成本</a><ul><li><a href=#21-%e8%af%84%e4%bc%b0%e6%95%b0%e6%8d%ae%e9%9b%86 aria-label="2.1. 评估数据集">2.1. 评估数据集</a></li><li><a href=#22-%e8%af%84%e4%bc%b0%e7%bb%93%e6%9e%9c aria-label="2.2. 评估结果">2.2. 评估结果</a></li><li><a href=#23-%e8%ae%ad%e7%bb%83%e4%b8%8e%e6%8e%a8%e7%90%86%e6%88%90%e6%9c%ac aria-label="2.3. 训练与推理成本">2.3. 训练与推理成本</a></li></ul></li><li><a href=#3-%e6%a8%a1%e5%9e%8b%e6%9e%b6%e6%9e%84 aria-label="3. 模型架构">3. 模型架构</a><ul><li><a href=#31-moe aria-label="3.1. MOE">3.1. MOE</a></li><li><a href=#32-mla aria-label="3.2. MLA">3.2. MLA</a></li><li><a href=#33-mtp aria-label="3.3. MTP">3.3. MTP</a></li></ul></li><li><a href=#4-%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd aria-label="4. 基础设施">4. 基础设施</a><ul><li><a href=#41-%e8%ae%a1%e7%ae%97%e9%9b%86%e7%be%a4 aria-label="4.1. 计算集群">4.1. 计算集群</a></li><li><a href=#42-dualpipe aria-label="4.2. DualPipe">4.2. DualPipe</a></li><li><a href=#43-fp8-training aria-label="4.3. FP8 Training">4.3. FP8 Training</a></li></ul></li><li><a href=#5-rl%e8%ae%ad%e7%bb%83%e7%ad%96%e7%95%a5 aria-label="5. RL训练策略">5. RL训练策略</a><ul><li><a href=#51-o1%e5%bc%95%e5%8f%91%e7%9a%84%e6%8e%a8%e7%90%86%e7%a0%94%e7%a9%b6%e7%83%ad%e6%bd%ae aria-label="5.1. O1引发的推理研究热潮">5.1. O1引发的推理研究热潮</a></li><li><a href=#52-%e4%bb%8eppo%e5%88%b0grpo aria-label="5.2. 从PPO到GRPO">5.2. 从PPO到GRPO</a></li><li><a href=#53-r1-zero%e8%ae%ad%e7%bb%83%e7%ad%96%e7%95%a5 aria-label="5.3. R1-Zero训练策略">5.3. R1-Zero训练策略</a></li><li><a href=#54-r1%e8%ae%ad%e7%bb%83%e7%ad%96%e7%95%a5 aria-label="5.4. R1训练策略">5.4. R1训练策略</a></li></ul></li><li><a href=#6-%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label="6. 参考文献">6. 参考文献</a></li></ul></div></details></div><div class=post-content><h1 id=1-背景>1. 背景<a hidden class=anchor aria-hidden=true href=#1-背景>#</a></h1><p>春节期间，DeepSeek爆火出圈，性能在开源和闭源模型中达到顶尖水平，同时显著降低了训练和推断成本，并在推理领域取得重大突破，被誉为开源领域的"ChatGPT时刻"。R1模型是DeepSeek一年来持续探索与积累的成果，体现了<strong>算法</strong>、<strong>架构</strong>与<strong>硬件</strong>的协同设计。本文将重点解析R1模型的核心算法，并简要介绍其基础设施。</p><div align=center><img src=/img/1-8881072.jpeg alt=img width=100%></div><h1 id=2-性能与成本>2. 性能与成本<a hidden class=anchor aria-hidden=true href=#2-性能与成本>#</a></h1><h2 id=21-评估数据集>2.1. 评估数据集<a hidden class=anchor aria-hidden=true href=#21-评估数据集>#</a></h2><ul><li><strong>MMLU</strong>(<strong>M</strong>assive <strong>M</strong>ultitask <strong>L</strong>anguage <strong>U</strong>nderstanding)：[<a href=https://arxiv.org/pdf/2009.03300>Paper</a>] [<a href=https://huggingface.co/datasets/cais/mmlu>Dataset Card</a>]</li></ul><p>这是一项大规模的多任务测试，包含来自不同知识领域的选择题。测试涵盖人文学科、社会科学、自然科学以及其他一些对某些人来说重要的学习领域。这包括57个任务，如基础数学、美国历史、计算机科学、法律等。要想在这一测试中取得高准确率，模型必须具备广泛的世界知识和强大的问题解决能力。</p><div align=center><img src=/img/2-8881072.png alt=img width=100%></div><ul><li><strong>MMLU-Pro</strong>：</li></ul><p>MMLU-Pro数据集是一个更加稳健且富有挑战性的大规模多任务理解数据集，旨在更严格地评估大型语言模型的能力。该数据集涵盖了多个学科的12,000道复杂问题。主要有三项改进：首先，将选项数量从4个增加至10个，提升了评估的真实性和挑战性，显著降低了随机猜测的得分；其次，提高了问题难度，增加更多推理型问题，使得CoT的结果可能比PPL高出20%；最后，通过增加干扰项，降低随机猜测概率，增强了基准测试的鲁棒性，模型得分对提示变化的敏感性从4-5%降至2%。</p><div align=center><img src=/img/3-8881072.png alt=img width=100%></div><ul><li><strong>GPQA</strong>：[<a href=https://arxiv.org/pdf/2311.12022>Paper</a>] [<a href=https://huggingface.co/datasets/Idavidrein/gpqa>Dataset Card</a>]</li></ul><p>GPQA包含了448道由生物学、物理学和化学领域的专家编写的多项选择题。我们确保这些问题的质量高且极具难度：在相应领域拥有或正在攻读博士学位的专家答题准确率为65%（在排除专家事后发现的明显错误后，准确率上升至74%），而技能高超的非专家验证者尽管平均花费超过30分钟并拥有无限制的网络访问权限（即问题"防谷歌"），准确率仅为34%。这些问题对于最先进的AI系统同样困难，我们基于GPT-4的最强基线模型准确率仅为39%。</p><div align=center><img src=/img/4-8881072.png alt=img width=100%></div><ul><li><strong>MATH 500</strong>：[<a href=https://arxiv.org/abs/2305.20050>Paper</a>] [<a href=https://huggingface.co/datasets/HuggingFaceH4/MATH-500>Dataset Card</a>]</li></ul><p>这个数据集包含了来自OpenAI在其论文《Let&rsquo;s Verify Step by Step》中创建的MATH基准测试的500道题目子集。</p><div align=center><img src=/img/5-8881072.png alt=img width=100%></div><ul><li><strong>AIME 2024</strong>：[<a href=https://huggingface.co/datasets/HuggingFaceH4/aime_2024>Dataset Card</a>]</li></ul><p>该数据集包含了2024年AIME I和AIME II测试中的30道题目。</p><div align=center><img src=/img/6-8881072.png alt=img width=100%></div><ul><li><strong>Codeforces</strong>：[<a href=https://codeforces.com/>Source</a>]</li></ul><p>编程试题。</p><ul><li><strong>SWE-bench</strong>：[<a href=https://huggingface.co/datasets/princeton-nlp/SWE-bench>Dataset Card</a>]</li></ul><p>SWE-bench 是一个用于测试系统自动解决 GitHub 问题能力的数据集。该数据集收集了来自 12 个热门 Python 仓库的 2,294 个"问题-拉取请求"对。评估通过单元测试验证进行，并以拉取请求后的行为作为参考解决方案。</p><h2 id=22-评估结果>2.2. 评估结果<a hidden class=anchor aria-hidden=true href=#22-评估结果>#</a></h2><div align=center><img src=/img/7-8881072.png alt=img width=100%></div><div align=center><img src=/img/8-8881072.png alt=img width=100%></div><h2 id=23-训练与推理成本>2.3. 训练与推理成本<a hidden class=anchor aria-hidden=true href=#23-训练与推理成本>#</a></h2><p><strong>训练成本</strong>：Llama3-405B使用了30.8M GPU时，而DeepSeek-V3 性能更强，仅使用了2.8M GPU时（计算量减少了约 <strong>11 倍</strong>）。</p><div align=center><img src=/img/9-8881072.png alt=img width=100%></div><p>Chat类模型推断价格对比：</p><div align=center><img src=/img/10-8881072.png alt=img width=100%></div><p>Reasoner类模型推断价格对比：</p><table><thead><tr><th></th><th>input (Price/1M)</th><th>Cached input (Price/1M)</th><th>Output (Price/1M)</th></tr></thead><tbody><tr><td>OpenAI o1</td><td><strong>$15.0</strong></td><td><strong>$7.5</strong></td><td><strong>$60.0</strong></td></tr><tr><td>OpenAI o3-mini</td><td><strong>$1.1</strong></td><td><strong>$0.55</strong></td><td><strong>$4.4</strong></td></tr><tr><td>DeepSeek R1</td><td><strong>$0.55</strong></td><td><strong>$0.14</strong></td><td><strong>$2.19</strong></td></tr></tbody></table><h1 id=3-模型架构>3. 模型架构<a hidden class=anchor aria-hidden=true href=#3-模型架构>#</a></h1><p>DeepSeek主打的卖点是计算开销低，从架构上主要通过<strong>MLA</strong>和<strong>MOE</strong>两个模块实现。</p><div align=center><img src=/img/94-8881072.png alt=DeepSeek模型架构图 style=zoom:33%></div><h2 id=31-moe>3.1. MOE<a hidden class=anchor aria-hidden=true href=#31-moe>#</a></h2><p><strong>MOE</strong>(<strong>M</strong>ixture <strong>o</strong>f <strong>E</strong>xpert)自Google提出以来便应用到多个领域，包括NLP、多模态、视觉和推荐系统中。大语言模型参数量与性能有密切关系，但参数量增大也会带来训练和推断成本的上升。MOE是一种在扩大模型参数时管理计算成本的非常有效的架构。</p><div align=center><img src=/img/11-8881072.png alt=MOE代表工作 width=100%></div><p>MOE可以分为Dense MoE和Sparse MoE两种类型。Dense MoE的特征在于所有专家都会被激活，只是每个专家承担的权重不同，可以理解为一种加权投票机制，每个专家负责不同的能力。然而，这种架构并不能减少计算量。相较之下，Sparse MoE只选择性激活TopK个专家，从而显著降低计算量。因此，DeepSeek选择采用Sparse MoE架构。</p><div align=center><img src=/img/95-8881072.png alt=MOE分类 style=zoom:50%></div><p>在DeepSeekMoE模型中，相较于传统的Naive Sparse MoE，有两项主要改进。首先，DeepSeekMoE将专家（Expert）的数量增加了一倍，这样每个专家可以学习到更加差异化的知识。其次，模型引入了共享专家（Shared Expert）。在传统的路由策略中，被分配给不同专家的token可能共享某些知识或信息。因此，不同专家可能在各自的参数中包含相同的知识，这导致参数的冗余。通过引入专门用于捕获和整合这些共同知识的共享专家，可以有效地缓解路由专家之间存在的参数冗余问题。</p><div align=center><img src=/img/96-8881072.png alt=img style=zoom:50%></div><p>自动学习到的路由策略可能会遇到负载不均衡(load imbalance)的问题，这表现为两个显著的缺陷。首先，存在路由崩溃的风险，即模型总是只选择少数专家，导致其他专家无法得到充分的训练。其次，如果专家分布在多个设备上，负载不均衡会加剧计算瓶颈。</p><p>解决负载均衡常用的方法是Switch Transformer中提出的辅助Loss：</p><div align=center><img src=/img/97-8881072.png alt=img style=zoom:33%></div><p>$f_i$即真实分配给expert $i$ 的概率，$P_i$ 为模型计算的分配给expert $i$ 的概率。文中认为loss会在 $f$ 和 $P$ 都是均匀分布时最小，此时每个专家被分配的概率都是相等的。例如有两个专家，那么loss的值为[0.5,0.5] * [0.5,0.5] = 0.5。但是这个结论是错误的：</p><div align=center><img src=/img/17-8881072.png alt=img width=100%></div><p>另外从直觉上，最小化这个loss意味着最小化 $\langle f, P \rangle$，而内积代表了相关性，这也并不合理。除此之外，这个辅助Loss只是想在expert之间做负载均衡，loss过大也会影响模型效果。</p><p>DeepSeek提出Loss Free的方法来解决负载不均衡的问题。在计算gate softmax时考虑此时每个expert的分配情况，从而进行动态调整权重。</p><div align=center><img src=/img/19-8881072.png alt=img width=100%></div><div align=center><img src=/img/98-8881072.png alt=img style=zoom:50%></div><div align=center><img src=/img/20-8881072.png alt=img width=100%></div><h2 id=32-mla>3.2. MLA<a hidden class=anchor aria-hidden=true href=#32-mla>#</a></h2><p><strong>MLA</strong>(<strong>M</strong>ulti-head <strong>L</strong>atent <strong>A</strong>ttention)的核心思想是通过压缩KV，降低KV Cache存储压力，这是DeepSeek降本的核心设计之一。</p><p>Self Attention的核心思想是每个token的表示都是所有token的加权求和，权重即为token之间的correlation。每个Q、K、V都会被切成若干个head。</p>$$
\begin{aligned}
\mathbf{q}_t &= W^Q \mathbf{h}_t = [\mathbf{q}_{t,1}; \mathbf{q}_{t,2}; \ldots; \mathbf{q}_{t,n_h}], \\
\mathbf{k}_t &= W^K \mathbf{h}_t = [\mathbf{k}_{t,1}; \mathbf{k}_{t,2}; \ldots; \mathbf{k}_{t,n_h}], \\
\mathbf{v}_t &= W^V \mathbf{h}_t = [\mathbf{v}_{t,1}; \mathbf{v}_{t,2}; \ldots; \mathbf{v}_{t,n_h}], \\
\mathbf{o}_{t,i} &= \sum_{j=1}^{t} \text{Softmax}_j \left( \frac{\mathbf{q}_{t,i}^T \mathbf{k}_{j,i}}{\sqrt{d_h}} \right) \mathbf{v}_{j,i}, \\
\mathbf{u}_t &= W^O [\mathbf{o}_{t,1}; \mathbf{o}_{t,2}; \ldots; \mathbf{o}_{t,n_h}],
\end{aligned}
$$<p>主流的LLM均为Casual Decoder架构，每个token只能看到前序的token，不能看到后面的token。如果每个token生成时都重新计算前序所有token的KV会产生大量的冗余计算。因此可以把之前计算好的KV缓存下来，以<strong>空间换时间</strong>，这就是所谓的KV Cache。</p><div align=center><img src=/img/22-8881072.png alt=img width=100%></div><p>当token数较多时也会带来性能瓶颈，因此产生了<strong>GQA</strong>和<strong>MQA</strong>这种工作。</p><div align=center><img src=/img/23-8881072.png alt=img width=100%></div><p>MLA核心思路是将KV映射到一个语义空间，需要的时候再进行还原，这样大大降低了Cache大小。</p><div align=center><img src=/img/99-8881072.png alt=img style=zoom:33%></div><p>另外在推断的时候，$W^{UK}$ 能被吸收到 $W^Q$ 中，$W^{UV}$ 能被吸收到 $W^O$ 中，因此并不需要按公式还原出 $K$ 和 $V$，这也意味着计算也是在Latent Space的，和Stable Diffusion等工作的思路很相似。我们以 $W^{UK}$ 为例，计算分数时：</p>$$
q^T k = (W^Q h)^T (W^{UK} c^{KV}) = h^T [(W^Q)^T W^{UK}] c^{KV} = h^T W^Q_{new} c^{KV}
$$<p>在上述计算过程中，位置向量未被考虑。Transformer中的位置编码通常分为三类：1）<strong>绝对位置编码</strong>：为每个位置分配一个可训练或固定的位置向量，应用到token embedding上。其优点在于简单实现，但缺点在于扩展性差，并且不包含相对位置信息。例如，位置0和位置1之间的差异无法与位置1和位置200之间的差异呈现实际对比。2）<strong>相对位置编码</strong>：应用到查询（Q）和键（K）上，具有较好的扩展性。然而，计算开销较大，并且不适用于KV Cache架构。3）<strong>旋转位置编码（RoPE）</strong>：结合了绝对和相对位置编码的优点。通过向量旋转的方式，旋转角度与绝对位置线性相关，同时在QK计算中能够体现相对位置信息。</p><div align=center><img src=/img/32-8881072.png alt=img width=100%></div><p>然而将RoPE直接应用到MLA中会导致 $W^{UK}$ 不能被吸收到 $W^Q$ 中，导致MLA的计算开销增大。具体来说：</p>$$
\begin{aligned}
\text{RoPE}(q_t)^T \text{RoPE}(k_m) &= (R^q_t q_t)^T (R^k_m k_m) \\
&= q_t^T (R^q_t)^T R^k_m k_m \\
&= (W^Q h_t)^T (R^q_t)^T R^k_m (W^{UK} c^{KV}_m) \\
&= h_t^T (W^Q)^T \overline{(R^q_t)^T R^k_m} W^{UK} c^{KV}_m
\end{aligned}
$$<p>中间的两个旋转矩阵是和位置相关的，因此 $W^{UK}$ 不能被吸收到 $W^Q$ 中，需要每次重新计算。论文提出使用额外的一些head计算位置向量，然后再拼到QK中。这意味着也要同时缓存 $k^R_t$。</p><div align=center><img src=/img/39-8881072.png alt="DeepSeek MLA" width=100%></div><h2 id=33-mtp>3.3. MTP<a hidden class=anchor aria-hidden=true href=#33-mtp>#</a></h2><p>DeepSeek <strong>MTP</strong>(<strong>M</strong>ulti-<strong>T</strong>oken <strong>P</strong>rediction)能够提升数据利用效率，也提升了模型的规划能力。主要受两篇工作启发得到，一是提升训练效率的Google MTP，二是提升推理效率的EAGLE。</p><p>传统的语言模型（LLM）在训练时通常只关注于预测下一个可能的Token。这种方法存在两个明显的局限性。首先，由于训练的信号较弱，模型对那些在句子中起重要转折作用的词汇（Hard Transitions Token）往往关注不足。其次，这种逐词预测的方式缺乏全局的规划能力，而人类在组织语言时通常是以段落为单位进行构思，而不是逐词考虑。基于上述背景，Google提出MTP，把模型最后一层的Head进行分组，每一层分别预测不同位置的token。</p><div align=center><img src=/img/40-8881072.png alt="Google MTP" width=100%></div><p>从结果上来看，引入MTP后模型效果得到明显提升。从分析上来看，模型增加了对hard transition token的训练信号。如下图所示，如果只预测next one，那么"5->A"的训练信号只有1/7=14%，而预测next three时，hard transition token占比为6/21=28%，可以看到训练信号大幅增加。但MTP训练时每个分组head都是独立的(parallel heads)，这违背了自回归的设计原则。</p><div align=center><img src=/img/41-8881072.png alt=img width=100%></div><p>另一篇借鉴的工作是大模型推理加速相关工作-Speculative Decoding.</p><div align=center><img src=/img/42-8881072.png alt="Speculative Decoding工作示例" width=100%></div><p>EAGLE是Speculative Decoding一篇知名工作，文中验证了Causal Heads优于Parallel Heads。因此deepseek将MTP中的Parallel Heads改成Causal Heads.</p><div align=center><img src=/img/43-8881072.png alt=img width=100%></div><h1 id=4-基础设施>4. 基础设施<a hidden class=anchor aria-hidden=true href=#4-基础设施>#</a></h1><h2 id=41-计算集群>4.1. 计算集群<a hidden class=anchor aria-hidden=true href=#41-计算集群>#</a></h2><p>DeepSeek-V3在配备有<strong>2048块NVIDIA H800 GPU</strong>的集群上进行训练。H800集群中的每个节点包含8块通过NVLink和NVSwitch连接的GPU。在不同节点之间，使用InfiniBand (IB)互连来实现通信。</p><h2 id=42-dualpipe>4.2. DualPipe<a hidden class=anchor aria-hidden=true href=#42-dualpipe>#</a></h2><p>流水线并行是一种提高计算效率的方法，通过将任务分解为多个阶段，并在不同计算单元之间传输数据，从而实现多个任务的重叠执行。具体来说，流水线并行像工厂流水线一样，将一项任务分成多个连续的步骤，每个步骤由不同的计算单元（例如处理器或加速器）负责。这种并行化可以显著减少模型训练或推理的时间。模型做一轮forward和backward的过程如下，我们会发现后面层需要等前面的计算完才能开始计算，会导致GPU在一段时间是闲置的。空白部分所表示的时间段里，总有GPU在空转。在Gpipe中，将阴影部分定义为bubble。</p><div align=center><img src=/img/44-8881072.png alt=流水线并行 width=100%></div><p>对于 DeepSeek-V3，由跨节点专家并行引入的通信开销导致计算与通信比率约为 1:1，这种情况效率较低。为了解决这一挑战，deepseek设计了一种创新的流水线并行算法，称为 DualPipe。该算法通过有效地重叠正向和反向的计算—通信阶段，加速了模型训练，并减少了流水线气泡。DualPipe 的核心理念是<strong>重叠单个正向和反向片段中的计算和通信</strong>。具体来说，我们将每个片段分为四个组成部分：注意力（attention）、全对全调度（all-to-all dispatch）、多层感知器（MLP）和全对全组合（all-to-all combine）。例如AB两个块，A块在前向计算时，B块做反向传播的通信，反之亦然。</p><p>&ldquo;全对全&rdquo;(&ldquo;all-to-all&rdquo;)通常用于描述一种网络通信模式，其中每个节点都需要与系统中的其他所有节点进行数据交换。这种通信模式常用于分布式计算和并行计算框架中，以便协调多个计算节点之间的数据共享和同步。</p><div align=center><img src=/img/45-8881072.png alt=img width=100%></div><p>通过这种方式，大幅提高了GPU利用率：</p><div align=center><img src=/img/46-8881072.png alt=img width=100%></div><h2 id=43-fp8-training>4.3. FP8 Training<a hidden class=anchor aria-hidden=true href=#43-fp8-training>#</a></h2><p>通常我们训练神经网络模型的时候默认使用的数据类型为FP32，而混合精度训练是指在训练的过程中，同时使用FP32和低精度（FP16、FP8），从而在尽量保持模型精度持平的条件下，加快训练时间、减少训练时内存占用。Deepseek提出了一种用于FP8训练的混合精度框架。在这个框架中，大多数计算密集型操作在FP8中进行，而一些关键操作则战略性地保持其原始数据格式，以平衡训练效率和数值稳定性。模型效果损失能够稳定控制在**0.25%**以内。</p><p>为了提升模型效果设计了两种优化手段：</p><ol><li><strong>细粒度量化</strong>. 在低精度训练中，FP8格式因其有限的动态范围而面临溢出和下溢的问题。传统方法通过缩放输入张量来缓解，但对异常值敏感。为解决此问题，deepseek提出更细致的量化方法：对激活值以1x128的块缩放，对权重以128x128的块缩放。这种方法提高了量化过程对异常值的适应性。</li><li><strong>提高累积精度</strong>. 低精度GEMM（广义矩阵乘法）操作常面临下溢问题，累加精度依赖高精度处理，通常是FP32。然而，在NVIDIA H800 GPU上的FP8 GEMM累加精度仅约14位，低于FP32。为解决此问题，我们建议将运算提升到CUDA核心，以实现更高精度。具体过程在Tensor核心上执行MMA时，使用有限位宽累加中间结果，达到𝑁𝐶间隔时，将部分结果复制到CUDA核心的FP32寄存器进行全精度FP32累加。</li></ol><div align=center><img src=/img/47-8881072.png alt=img width=100%></div><h1 id=5-rl训练策略>5. RL训练策略<a hidden class=anchor aria-hidden=true href=#5-rl训练策略>#</a></h1><p>预训练部分较为常规，我们重点关注R1涉及到的RL训练策略。</p><h2 id=51-o1引发的推理研究热潮>5.1. O1引发的推理研究热潮<a hidden class=anchor aria-hidden=true href=#51-o1引发的推理研究热潮>#</a></h2><div align=center><img src=/img/48-8881072.png alt=img width=100%></div><p>gpt-o1的推出引发了推理研究的热潮，研究重点为构造COT推理数据。奖励设计可分为结果监督(ORM)和过程监督(PRM)，另外也有研究基于搜索的方法，例如MCTS.</p><p>ORM的代表工作为<strong>StaR</strong>，提出自举式数据生成方案，大幅提升了模型推理能力。首先根据原始问题让大模型生成&lt;<strong>答案</strong>，<strong>推理</strong>>对，对于答案生成正确的作为可用微调样本。对于错误答案的，根据答案提示让模型有更大概率生成更好的解释，然后用于训练中间模型。最终训练模型时，只利用能推理出正确答案的样本，对于不能生成正确答案的直接丢弃。方法有个明显缺陷是对于推理过程没有校验，即使答案正确推理也有可能是错误的，尤其是对于二元判别，生成数据噪声比较大。</p><div align=center><img src=/img/49-8881072.png alt=img width=100%></div><p>OpenAI在2023年的研究成果显示，通过过程监督训练出的奖励模型比结果监督更可靠。他们利用先进的过程监督方法解决了78.2%的MATH测试集问题，并证明大型奖励模型可以有效地指导小型奖励模型进行类似人类的监督，可用于高效的大规模数据收集。</p><div align=center><img src=/img/50-8881072.png alt=img width=100%></div><h2 id=52-从ppo到grpo>5.2. 从PPO到GRPO<a hidden class=anchor aria-hidden=true href=#52-从ppo到grpo>#</a></h2><p><strong>强化学习</strong>是一种通过<strong>试错</strong>和从<strong>环境反馈</strong>中学习以优化<strong>序列决策</strong>问题的机器学习方法。游戏是一个典型的序列决策问题，玩家需要根据当前状态(<strong>State</strong>)做出决策(<strong>Action</strong>)，目标是获得游戏胜利(<strong>Reward</strong>)。强化学习的目标是<strong>最大化Expected Reward</strong>。</p><div align=center><img src=/img/100-8881072.png alt=img style=zoom:33%></div><p><strong>策略梯度</strong>(Policy Gradient)是一个比较直观的方法，直接利用<strong>梯度上升</strong>来最大化期望Reward. 下面是一个示例，输入是游戏的一帧画面 $s^n_t$，然后利用神经网络进行表征学习，最后输出Action $a^n_t$。如果不考虑Reward，其优化目标就是一个的典型的分类问题。</p><div align=center><img src=/img/101-8881072.png alt=img style=zoom:33%></div><p>策略梯度有两个重要改进，一是考虑到有些场景reward都是正的，例如考试分数都会大于0，因此需要减去一个baseline让reward有正有负。二是对于一个采样而言，所有action都是利用相同的reward，即使最终游戏胜利，里面也会存在一些差的action，因此需要为每个action分配合理的reward，即在状态 $s$ 下采取 $a$ 的未来期望收益。改进后的这一项被称为优势函数 $A^\theta(s_t, a_t)$，用来衡量状态 $s$ 下采取 $a$ 的<strong>相对优势</strong>。优势函数可以用值函数计算：$A^\theta(s_t, a_t) = Q(s_t, a_t) - V^\pi(s^n_t) = r^n_t + \gamma V^\pi(s^n_{t+1}) - V^\pi(s^n_t)$。$r^n_t$ 指状态 $s_t$ 采取 $a_t$ 所获得的即时收益，$V^\pi(s^n_t)$ 指在策略 $\pi$ 下状态 $s_t$ 的未来期望收益。</p><div align=center><img src=/img/102-8881072.png alt=img style=zoom:33%></div><p>计算优势函数有两种方法，一种是Monte-Carlo (MC)，使用完整轨迹的奖励，缺点是方差很大，另一种是Temporal difference (TD)，即采用一步轨迹的奖励，缺点是偏差太大。为了综合上述两种方法，常采用General Advantage Estimation (GAE)，即多步TD加权求和：</p><div align=center><img src=/img/103-8881072.png alt=img style=zoom:67%></div><p>另一个要解决的问题是采样问题，回顾下PG目标 $\nabla \bar{R}_\theta = E_{\tau \sim p_\theta(\tau)}[R(\tau) \nabla \log p_\theta(\tau)]$，这里的采样 $\tau$ 依赖要训练的策略网络 $\pi_\theta$。当 $\theta$ 更新时，我们必须重新采样训练样本，这显然非常费时。因此我们想利用另一个策略 $\pi'_\theta$ 去采样多条数据，这样 $\pi_\theta$ 可以重复利用数据。这里利用了重要性采样公式：</p>$$
E_{x \sim p}[f(x)] = E_{x \sim q}\left[f(x) \frac{p(x)}{q(x)}\right]
$$<p>那么PG目标就变成：$\nabla \bar{R}_\theta = E_{\tau \sim p_{\theta'}(\tau)}\left[\frac{p_\theta(\tau)}{p_{\theta'}(\tau)} R(\tau) \nabla \log p_\theta(\tau)\right]$。当采样网络 $\pi'_\theta$ 和策略网络 $\pi_\theta$ 分布差异太大会导致效果不好，而PPO提出将两个分布的差异建模到Loss中，$J^{\theta^k}_{PPO}(\theta) = J^{\theta^k}(\theta) - \beta KL(\theta, \theta^k)$。PPO2更为简化：</p><div align=center><img src=/img/104-8881072.png alt=img style=zoom:33%></div><p>应用到LLM训练中，PPO的优化目标为：</p><div align=center><img src=/img/76-8881072.png alt=img width=100%></div><p>同时为了避免RL过度优化，导致模型通用能力退化，标准RLHF为每个token的reward增加了惩罚项，避免过度偏离参考模型：</p><div align=center><img src=/img/105-8881072.png alt=img style=zoom:67%></div><p>由于PPO中使用的价值函数通常是与策略模型规模相当的另一个模型，它带来了大量的内存和计算负担。此外，在强化学习训练中，价值函数被用作方差减少的基线。然而，在LLM的背景下，通常只有最后一个标记会被奖励模型赋予奖励分数，这可能使得训练一个在每个标记上都准确的价值函数变得复杂。为了解决这个问题，deepseek提出了<strong>GRPO</strong>(<strong>G</strong>roup <strong>R</strong>elative <strong>P</strong>olicy <strong>O</strong>ptimization)，它避免了像PPO那样需要额外的价值函数近似，而是使用响应同一问题生成的多个采样输出的平均奖励作为基线。</p><div align=center><img src=/img/77-8881072.png alt=img width=100%></div><p>GRPO的优化目标如下：</p><div align=center><img src=/img/78-8881072.png alt=img width=100%></div><p>GRPO并没有在奖励中添加KL惩罚，而是通过将训练策略与参考策略之间的KL散度直接添加到损失中进行正则化，从而避免了复杂的 $\hat{A}_{i,t}$ 的计算。</p><div align=center><img src=/img/106-8881072.png alt=img style=zoom:33%></div><p>对于结果监督的RL(<strong>REINFORCE</strong>)，优势函数计算如下：</p>$$
\hat{A}_{i,t} = \tilde{r}_i = \frac{r_i - \text{mean}(\mathbf{r})}{\text{std}(\mathbf{r})}
$$<p>对于过程监督的RL(<strong>Actor-Critic</strong>)，优势函数计算如下：</p>$$
\hat{A}_{i,t} = \sum_{\text{index}(j) \geq t} \tilde{r}^{\text{index}(j)}_i, \quad \tilde{r}^{\text{index}(j)}_i = \frac{r^{\text{index}(j)}_i - \text{mean}(\mathbf{R})}{\text{std}(\mathbf{R})}
$$$$
\mathbf{R} = \{\{r^{\text{index}(1)}_1, \ldots, r^{\text{index}(K_1)}_1\}, \ldots, \{r^{\text{index}(1)}_G, \ldots, r^{\text{index}(K_G)}_G\}\}
$$<p>论文还验证了一个被广泛流传但未经充分验证的观点：代码训练可以提高推理能力。</p><div align=center><img src=/img/83-8881072.png alt=img width=100%></div><p>作者将SFT, RFT, DPO, PPO, GRPO抽象为统一的范式：</p><div align=center><img src=/img/107-8881072.png alt=img style=zoom:33%></div><p>这里有三个关键组件：1）数据源 $\mathcal{D}$，决定训练数据；2）奖励函数 $\pi_{rf}$，训练奖励信号的来源；3）算法 $\mathcal{A}$：处理训练数据和奖励信号以获得梯度系数 $GC$，确定对数据进行惩罚或强化的幅度。</p><div align=center><img src=/img/88-8881072.png alt=img width=100%></div><p>通过实验有两个观察：</p><ol><li>数据源分为在线采样和离线采样，前者使用实时策略模型的采样结果，后者依赖初始SFT模型。观察表明，Online RFT在基准测试中明显优于RFT，特别是在训练后期，因为来自actor的采样数据表现出更显著的差异，实时数据采样带来了明显优势。</li><li>奖励函数被分为"规则"和"模型"两部分，其中"规则"评估答案正确性，而"模型"使用奖励模型对响应评分。GRPO和Online RFT的主要区别在于：GRPO根据奖励模型的奖励值调整梯度系数，能够区分强化和惩罚不同程度的响应，而Online RFT缺少这一特征，对所有正确的响应以相同强度进行强化。</li></ol><p>关于RL为什么有效，文章给出一个较为有趣的观察。通过评估Instruct和RL模型，发现RL<strong>提升了Maj@K的表现，但没有提升Pass@K</strong>。这些发现表明，RL通过使输出分布更加稳健来增强模型的整体性能，换句话说，这种改进似乎是由于提升了TopK中的正确响应，而不是增强了基本能力。</p><div align=center><img src=/img/89-8881072.png alt=img width=100%></div><h2 id=53-r1-zero训练策略>5.3. R1-Zero训练策略<a hidden class=anchor aria-hidden=true href=#53-r1-zero训练策略>#</a></h2><p>R1-Zero不依赖监督数据，仅靠RL自驱学习就能达到很好的推理性能。R1-Zero用的强化学习算法就是上节的GRPO。设计了两个规则式Reward：</p><ol><li><strong>准确性奖励</strong>：准确性奖励模型评估响应是否正确。例如，对于具有确定性结果的数学问题，模型需要以指定格式（例如，在框内）提供最终答案，从而实现可靠的基于规则的正确性验证。同样，对于 LeetCode 问题，可以使用编译器根据预定义的测试用例生成反馈。</li><li><strong>格式奖励</strong>：除了准确性奖励模型之外，我们还采用了一种格式奖励模型，要求模型将其思维过程置于 &lsquo;<think>&rsquo; 和 &lsquo;</think>&rsquo; 标签之间。</li></ol><p>用到的训练模板如下：</p><div align=center><img src=/img/90-8881072.png alt=img width=100%></div><p>仅仅如此简洁的设计，在推理Benchmark上就达到了很高的水准：</p><div align=center><img src=/img/91-8881072.png alt=img width=100%></div><p>DeepSeek-R1-Zero在整个训练过程中，其思考时间呈现出持续的改进。这一进步并不是外部调整的结果，而是模型内部本质上的发展。DeepSeek-R1-Zero通过利用延长的测试时间计算，自然获得了解决越来越复杂推理任务的能力。这种计算涉及生成数百到数千个推理标记，使得模型能够以更深入的方式探索和完善其思维过程。</p><div align=center><img src=/img/108-8881072.png alt=img style=zoom:50%></div><p>在DeepSeek-R1-Zero的训练过程中，观察到一个特别有趣的现象，即出现了**&ldquo;顿悟时刻&rdquo;(aha moment)**。这一时刻发生在模型的中间版本。在这个阶段，DeepSeek-R1-Zero通过重新评估其初始方法，学会将更多的思考时间分配给一个问题。此行为不仅证明了模型日益增强的推理能力，也是强化学习如何引导出意外且复杂结果的一个引人入胜的例子。已经有多个工作能够复现"aha moment"。</p><div align=center><img src=/img/109-8881072.png alt=img style=zoom:50%></div><h2 id=54-r1训练策略>5.4. R1训练策略<a hidden class=anchor aria-hidden=true href=#54-r1训练策略>#</a></h2><p>尽管DeepSeek-R1-Zero表现出强大的推理能力，并能自主发展出意想不到的强大推理行为，但它仍面临一些问题。例如，DeepSeek-R1-Zero在可读性较差和语言混合等方面遇到挑战。为了使推理过程更加可读，R1训练结合了少量冷启动数据。该流程分为四个阶段：</p><ol><li><p><strong>冷启动</strong>. 一开始要收集少量的Long-CoT数据来微调模型，目的是<strong>防止早期训练不稳定和可读性差问题</strong>。</p></li><li><p><strong>推理导向的RL</strong>. 在对DeepSeek-V3-Base进行冷启动数据的微调后，采用与DeepSeek-R1-Zero相同的大规模强化学习训练过程。这一阶段的重点是提高模型的推理能力，尤其是在编码、数学、科学和逻辑推理等。为了缓解语言混合的问题，在RL训练中引入了<strong>语言一致性奖励</strong>，该奖励是根据CoT中目标语言单词的比例来计算的。虽然消融实验表明这种对齐会导致模型性能略有下降，但这一奖励符合人类偏好，使其更加易读。最后，通过直接相加推理任务的准确性和语言一致性奖励来形成最终奖励。然后对微调后的模型进行RL训练，直到在推理任务上达到收敛。</p></li><li><p><strong>拒绝采样和SFT</strong>. 当面向推理的强化学习（RL）收敛之后，我们利用得到的检查点来收集用于下一轮的有监督微调（SFT）数据。与最初的冷启动数据主要关注推理不同，此阶段结合了来自其他领域的数据，以增强模型在写作、角色扮演和其他通用任务方面的能力。具体来说，按照以下步骤<strong>生成800K训练数据，并对DeepSeek-V3-Base进行了两轮的微调</strong>。</p></li><li><p><strong>推理数据.</strong> 编写了推理提示，通过拒绝采样从RL训练的检查点中生成推理轨迹。在前一个阶段，数据集中仅包含可以通过基于规则的奖励进行评估的数据。而在这一阶段，数据集得到了扩展，包含了一些使用生成式奖励模型产生的数据。此外，由于模型输出有时可能会显得冗长或难以理解，特意去除掉了混合语言、长段落及代码块中的链式思维。对于每个提示，生成了多个响应，但只保留了那些正确的版本。在整个过程中，收集了约60万条与推理相关的训练样本。</p></li><li><p><strong>非推理数据</strong>. 对于不涉及推理的数据类型，包括写作、事实问答、自我认知和翻译，采用了DeepSeek-V3流程，同时重用了部分DeepSeek-V3的SFT数据集。在某些非推理任务中，通过提示在回答问题前调用DeepSeek-V3生成潜在的链式思维。但对于诸如"hello"这类简单的查询，则不提供链式思维作为回应。最终，收集了大约20万条与推理无关的训练样本。</p></li><li><p><strong>面向所有领域的RL</strong>. 在第3阶段微调模型的基础上，进一步提升模型的有用性和无害性，同时改进其推理能力。对于推理任务，采用规则的奖励来指导。对于一般任务，采用奖励模型来对齐人类偏好。</p></li></ol><div align=center><img src=/img/92-8881072.png alt=img width=100%></div><p>蒸馏实验有两个发现，一是通过大模型蒸馏能够大幅提升小模型能力；二是小模型直接RL训练的效果不如蒸馏效果，这也反映了训练更大模型的必要性。</p><div align=center><img src=/img/93-8881072.png alt=img width=100%></div><p>文章最后也提到了尝试PRM和MCTS的失败经历，探讨了这两种方法的弊端。</p><h1 id=6-参考文献>6. 参考文献<a hidden class=anchor aria-hidden=true href=#6-参考文献>#</a></h1><ul><li><a href=https://arxiv.org/abs/2401.02954>DeepSeek LLM: Scaling Open-Source Language Models with Longtermism</a></li><li><a href=https://arxiv.org/abs/2401.06066>DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models</a></li><li><a href=https://arxiv.org/abs/2405.04434>DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a></li><li><a href=https://arxiv.org/pdf/2412.19437v1>DeepSeek-V3 Technical Report</a></li><li><a href=https://arxiv.org/abs/2501.12948>DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></li><li><a href=https://semianalysis.com/2025/01/31/deepseek-debates/>DeepSeek分析-Semianalysis</a></li><li><a href=https://arxiv.org/pdf/2407.06204>A Survey on Mixture of Experts</a></li><li><a href=https://arxiv.org/pdf/2101.03961>Switch Transformers</a></li><li><a href=https://www.cs.princeton.edu/courses/archive/fall22/cos597G/lectures/lec16.pdf>Switch Transformers课程</a></li><li><a href=https://arxiv.org/pdf/2408.15664>Auxiliary-Loss-Free Load Balancing Strategy for Mixture-of-Experts</a></li><li><a href=https://arxiv.org/pdf/2104.09864>RoFormer: Enhanced Transformer with Rotary Position Embedding</a></li><li><a href=https://medium.com/@ngiengkianyew/understanding-rotary-positional-encoding-40635a4d078e>Understanding Rotary Positional Encoding</a></li><li><a href="https://openreview.net/pdf?id=pEWAcejiU2">Better & Faster Large Language Models via Multi-token Prediction</a></li><li><a href=https://arxiv.org/pdf/2211.17192>Fast Inference from Transformers via Speculative Decoding</a></li><li><a href=https://arxiv.org/pdf/2408.08146v1>KOALA: Enhancing Speculative Decoding for LLM via Multi-Layer Draft Heads with Adversarial Learning</a></li><li><a href=https://arxiv.org/pdf/2401.15077>EAGLE: Speculative Sampling Requires Rethinking Feature Uncertainty</a></li><li><a href=https://arxiv.org/pdf/2401.10774>MEDUSA: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads</a></li><li><a href=https://research.google/blog/introducing-gpipe-an-open-source-library-for-efficiently-training-large-scale-neural-network-models/>Introducing GPipe</a></li><li><a href=https://arxiv.org/pdf/2402.03300>DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models</a></li><li><a href=https://arxiv.org/pdf/1707.06347>Proximal Policy Optimization Algorithms</a></li><li><a href="https://www.youtube.com/watch?v=z95ZYgPgXOY&amp;list=PLJV_el3uVTsODxQFgzMzPLa16h6B8kWM_&amp;index=1&amp;ab_channel=Hung-yiLee">Deep Reinforcement Learning, 2018</a></li><li><a href=https://www.cnblogs.com/zhangxianrong/p/18277086>PPO原理与源码解读</a></li><li><a href="https://www.youtube.com/watch?v=axlQI7fGn_8&amp;ab_channel=EZ.EncoderAcademy">DeepSeek V3解读</a></li><li><a href=https://arxiv.org/pdf/2203.14465>STaR: Self-Taught Reasoner Bootstrapping Reasoning With Reasoning</a></li><li><a href=https://arxiv.org/pdf/2305.20050>Let&rsquo;s Verify Step by Step</a></li><li><a href=https://www.zhihu.com/question/10175007563>如何评价deepseek-R1与deepseek-R1-Zero模型？</a></li><li><a href=https://blogs.cisco.com/security/evaluating-security-risk-in-deepseek-and-other-frontier-reasoning-models>Evaluating Security Risk in DeepSeek</a></li><li><a href=https://arxiv.org/pdf/2405.10313>How Far Are We From AGI: Are LLMs All We Need?</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/><span class=title>« Prev</span><br><span>大模型在推荐领域的应用</span>
</a><a class=next href=https://hpzhao.github.io/posts/aicon2024-%E5%8C%97%E4%BA%AC/><span class=title>Next »</span><br><span>AI Con 2024参会总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://hpzhao.github.io/>Huaipeng's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>