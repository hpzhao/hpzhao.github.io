<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>大模型在推荐领域的应用 | Huaipeng's Blog</title><meta name=keywords content><meta name=description content="本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.
1. 相关背景
1.1. 现代推荐系统架构
推荐系统的核心任务就是在给定一个用户$u \in \mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\mathcal{i}k \in \mathscr{I}$即："><meta name=author content="Huaipeng Zhao"><link rel=canonical href=https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://hpzhao.github.io/img/logo.gif><link rel=icon type=image/png sizes=16x16 href=https://hpzhao.github.io/img/logo.gif><link rel=icon type=image/png sizes=32x32 href=https://hpzhao.github.io/img/logo.gif><link rel=apple-touch-icon href=https://hpzhao.github.io/logo.gif><link rel=mask-icon href=https://hpzhao.github.io/logo.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"><meta property="og:site_name" content="Huaipeng's Blog"><meta property="og:title" content="大模型在推荐领域的应用"><meta property="og:description" content="本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.
1. 相关背景 1.1. 现代推荐系统架构 推荐系统的核心任务就是在给定一个用户$u \in \mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\mathcal{i}k \in \mathscr{I}$即："><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-01T00:58:22+08:00"><meta property="article:modified_time" content="2025-05-01T00:58:22+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="大模型在推荐领域的应用"><meta name=twitter:description content="本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.
1. 相关背景
1.1. 现代推荐系统架构
推荐系统的核心任务就是在给定一个用户$u \in \mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\mathcal{i}k \in \mathscr{I}$即："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hpzhao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"大模型在推荐领域的应用","item":"https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"大模型在推荐领域的应用","name":"大模型在推荐领域的应用","description":"本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.\n1. 相关背景 1.1. 现代推荐系统架构 推荐系统的核心任务就是在给定一个用户$u \\in \\mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\\mathcal{i}k \\in \\mathscr{I}$即：\n","keywords":[],"articleBody":"本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.\n1. 相关背景 1.1. 现代推荐系统架构 推荐系统的核心任务就是在给定一个用户$u \\in \\mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\\mathcal{i}k \\in \\mathscr{I}$即：\n$$ \\bigl[i_k\\bigr]_{k=1}^N \\leftarrow \\mathbf{RS}(u, c, \\mathscr{I}),\\; u \\in \\mathcal{U},\\; i_k \\in \\mathscr{I} $$上下文是个比较重要的变量，比如同一用户在首猜和在LazFlash推荐的结果差异很大。\n推荐系统大致可分为数据收集、特征工程、特征编码、打分/排序、用户交互和流程控制器几个环节。除了数据收集外，其他环节大模型都可以参与其中。\n1.2. 分类范式 LLM在推荐系统的应用可以从两个视角来看：Where和How。Where是指LLM在推荐系统哪个环节应用，How是指LLM在推荐系统的应用方式(训练和推理)。CRM表示Conventional Recommendation Model。\n2. Where to adapt LLM 2.1. 特征工程 2.1.1. 特征增强 由于具有强大的推理能力和开放世界知识，LLM（大型语言模型）常被视为灵活的知识库。因此，它能够提供辅助特征，以更好地进行用户偏好建模和项目内容理解。CUP 采用 ChatGPT 根据用户评论文本总结每个用户的兴趣，通过关键词压缩用户画像数据，使其可以被小规模语言模型（如 BERT）编码。\n2.1.2. 样本生成 除了特征增强，LLM 还用于生成合成样本，丰富训练数据集，提高模型预测质量。Zhang 等人进一步尝试结合多个大型语言模型作为代理，以模拟更真实推荐场景中的细粒度用户交流和交互。\n2.1.3. 相关工作 2.1.3.1. MINT 论文：Large Language Model Augmented Narrative Driven Recommendations\nMINT表示Data augMentation with INteraction narraTives。\n叙事驱动推荐（Narrative-driven recommendation，NDR）是一个信息访问问题，其中用户通过详细描述自己的偏好和情境来请求推荐，例如，旅行者在描述他们的喜好/厌恶和旅行情况时请求推荐景点。随着基于自然语言的对话接口在搜索和推荐系统中的崛起，这些请求变得越来越重要。然而，NDR缺乏丰富的用于模型训练的训练数据，当前的平台通常不支持这些请求。作者利用大模型扩充数据来训练NDR模型。核心思路是利用现有的user-item交互数据，用大模型将用户兴趣总结成陈述性文本。\n2.1.3.2. TagGPT 论文：TagGPT: Large Language Models are Zero-shot Multimodal Taggers\n标签在现代互联网时代的各种应用中（如搜索引擎和推荐系统）对多媒体内容的有效分发起着关键作用。本文提出了TagGPT，一个能够以完全零样本方式进行标签提取和多模态标签化的全自动系统。我们的核心启示是，通过精细的提示工程，LLMs能够根据多模态数据的文本线索（例如OCR, ASR, 标题等）提取和推理出合适的标签。具体来说，为了自动构建一个高质量的标签集，以反映特定应用的用户意图和兴趣，TagGPT通过提示LLMs从一系列的原始数据中预测大规模的候选标签，并通过频率和语义进行筛选。\n抽取的标签也做了进一步后处理，频率太高的没有区分性，频率太低的没有代表性。另外也对相似度过高的tag进行合并。\n下图是抽取结果的一个示例：\n2.2. 特征编码 利用LLM作为辅助文本特征编码器，从而获得两大主要好处：（1）进一步为后续的神经推荐模型提供丰富的user/item表示，其中包含语义信息；（2）通过自然语言作为桥梁，实现跨领域推荐，在这种情况下，ID特征字段可能不共享。\n2.2.1. 表示增强 在一些文本特征丰富的场景(例如item有标题、详细描述等)，LLM被用于特征编码器。LLM4ARec利用GPT2从用户画像和评论中提取个性化的方面术语和潜在向量，以更好地辅助推荐。在一些特殊情况下，LLM编码的语义表示不会直接用作后续评分/排序函数的输入。相反，它通过量化被转换为一系列离散的token，以适应需要离散输入的评分/排序函数（例如，生成推荐）。\n2.2.2. 统一跨领域推荐 除了改善user/item表示之外，LLM作为特征编码器还可以实现迁移学习和跨领域推荐，自然语言在其中起到了对齐不同领域异构信息的桥梁作用。ZESRec应用BERT将物品描述转换为通用的语义表示，用于零样本推荐。在UniSRec中，物品表示通过一个固定的BERT模型和一个轻量级的MoE增强网络进行学习，以实现跨领域序列推荐。\n2.2.3. 相关工作 2.2.3.1. LLM探索Text CF上限 论文：Exploring the Upper Limits of Text-Based Collaborative Filtering Using Large Language Models: Discoveries and Insights\n现存TCF系统大都采用参数规模较小的BERT系架构编码item，本文探索利用LLM提升TCF上限。针对下面几个问题有初步结论。\nQ1：TCF范式达到性能瓶颈了么？\n还未看到瓶颈，随着参数规模增大，性能一直在提升。 Q2：175B的LLM能得到通用表征么？\n在推荐任务上fine-tune的LLM性能有明显提升，说明现在的LLM生成的Embedding远不够通用 Q3：基于175B参数LLM的TCF能轻易替代IDCF么？\n175B的TCF在某些场景下和IDCF性能可比，但远谈不上能够替代，尤其是考虑到IDCF的高效性。 2.2.3.2. VQ-Rec 论文：Learning Vector-Quantized Item Representation for Transferable Sequential Recommenders\n基于IDCF方法的推荐模型可迁移性差，因此出现大量工作研究利用item的文本来表示item，在跨领域迁移时取得了不错的结果。然而item和其文本绑定太紧密可能会造成潜在问题，例如过分强调文本特征而忽略交互特征，两个文本相似的item其表现可能差异很大。因此本文提出VQ技术建模item表示，让其既具备文本特征，又能通过协同过滤更新，减少对推荐系统影响。\nVQ-Rec分为三步：\nVQ Item表征. 利用PLM对item的文本进行编码得到item embedding，然后通过PQ将item embedding映射为D个code，再给每个code分配一个可学习embedding。item最终由这D个code池化后的向量表示。 对比学习预训练. 为提高跨领域能力，提高方法通用性，在多领域推荐数据上预训练code emb和Transformer参数，采用对比学习方式训练。为让负样本更有意义，摈弃了batch内随机采样，采用了两种方案构造hard负样本：一是半混合负样本，二是混合领域采样。 跨领域微调. 由于不同领域文本分布差异较大，因此对item-\u003ecode映射重新适配，并微调code emb，fix住Transformer参数。 2.3. 打分/排序函数 打分/排序的目标一般和推荐系统的最终目标息息相关。根据LLM所解决的不同任务，分为三类：1）item打分任务 2）item生成任务 3）混合任务\n2.3.1. item打分任务 在item打分任务中，LLM扮演pointwise打分函数$F(u,i)$。候选商品最终的序由排序分决定：\nPre-filter为item预选阶段，主要是为了减小候选集规模，一般包含检索和粗排阶段。\nLLM产生token的一般流程如下：\n其中$\\hat{t}$为离散token。但打分任务一般要求打分函数产生有意义的实数，例如CTR任务要求输出分数为$\\hat{y} \\in [0,1]$，打分预测任务要求$\\hat{y} \\in [0,5]$。针对这一问题，通常有三种主要解决方法：\n第一种方法摈弃LLM解码层，采用单塔结构，直接将隐层$h$映射为分数：\n输入提示需要包含用户和item信息，以支持基于隐层的偏好估计。E4SRec通过预先学习的用户和物品ID嵌入来构建个性化提示，以实现精确的偏好估计。CER加强了推荐内容与其自然语言解释之间的一致性，以提高评分预测的性能。\n第二种方法也摈弃了LLM解码层，采用双塔结构：\n在这类工作中，一般重点是设计不同的辅助结构以使用LLM增强双侧信息。通过采用编码器-解码器LLM，TASTE首先将每个用户行为编码成一个软提示向量，然后利用解码器从软提示序列中提取用户偏好。\n第三种方法保留了LLM解码层，将打分问题转化成二元问题，即给定U和I，U是否喜欢I，基于候选答案概率归一化得到最终分数：\n2.3.2. item生成任务 在item生成任务中，LLM作为生成函数$F(u)$直接生成最终item排序列表，仅需要一次前向计算。一般而言，item生成任务高度依赖LLM的内在推理能力，其过程可表示为：\n根据是否提供候选item，其方案可分为两类：1）开放集item生成 2）闭集item生成。\n2.3.2.1. 开放集item生成 LLM直接根据user profile和历史行为生成用户偏好的排序item列表。由于在输入提示中并未提供候选item，因此可能会产生幻觉问题，生成的item无法准确匹配item池中的item。因此除了设计输入提示模版和微调算法之外，还需要在item生成后进行匹配后处理操作 ，以克服幻觉问题。这一过程描述如下：\n其中$\\hat{i_k}$是LLM生成的item，$i_k$为item池中真实存在的item，Match为匹配函数。\nLANCER采用知识增强的前缀微调来进行生成基础，并进一步应用余弦相似度将生成item文本的编码表示与通用item池进行匹配。Di Palma 等人利用ChatGPT进行用户兴趣建模和下一个item标题生成，并使用Damerau-Levenshtein 距离进行item匹配。\n除了以文本方式生成item外，另一研究方向聚焦于将语言空间与基于ID的推荐空间对齐，从而使LLM可以直接生成item ID。例如，Hua 等人探索了更好的item索引方法（如顺序索引、协作索引），以提升此类索引生成任务的性能。LightLM设计了一种轻量级 LLM，结合了精心设计的用户和item索引，并使用约束束搜索进行开放集合item ID 的生成。此外，LLaRA在 LLM 的输入提示中采用了一种新颖的混合方法，将传统推荐系统中的基于 ID 的item嵌入与文本item特征相结合。其他关于开放集合item生成的典型工作包括：GenRec，TransRec，LC-Rec，ControlRec和POD。\n2.3.2.2. 闭集item生成 LLM需要根据给定的候选item集合排序。候选item一般由pre-filter挑选得到。受限于LLM上下文窗口长度，候选item数量通常最多设置成20个，一般是重排阶段。过程形式化为：\n例如，LlamaRec 采用 LRURec作为检索器，并在预筛选的项目上微调 LLaMA2 以进行列表排名。DRDT通过多轮迭代反思对给定候选项目进行排名，以逐步优化排列表。\n相比之下，开放集生成任务通常会遭遇生成幻觉问题，即生成的item可能无法与通用item池中的确切item匹配。因此，后续的生成匹配功能是非常必要的，这增加了推理推理成本甚至可能影响最终的推荐性能，尤其是在item文本与大型语言模型的语言分布差异很大的场景中。与此相反，封闭集生成任务使用轻量级检索模型作为预筛选器，提供一组明确的候选item，因此大型语言模型可以缓解幻觉问题。然而，将候选item引入大型语言模型的输入提示中会导致其他问题。首先，由于上下文窗口的限制，大型语言模型无法处理大量的候选item（通常少于20个），最终的推荐性能可能会受到检索模型（即预筛选器）的限制。此外，Ma 等和 Hou 等发现，在提示中打乱候选item的顺序会影响排名结果，导致不稳定的推荐结果。上述封闭集生成任务的问题本质上源于输入提示中存在候选item集，这在开放集生成任务中可以得到很好地解决。总的来说，我们可以观察到，开放集和封闭集生成任务在各自的优缺点上是互补的。因此，在实际应用中选择哪种任务实际上取决于我们在现实场景中遇到的具体情况和问题。\n2.3.2.3. 混合任务 在混合任务中，大型语言模型以多任务的方式运作，通过统一的语言接口处理item打分和生成任务。支持这种混合功能的基础是大型语言模型本质上是多任务学习器。例如，P5、M6-Rec和InstructRec通过不同的提示模板调整编码器-解码器模型，以更好地对齐一系列推荐任务，包括项目评分和生成任务。\n2.3.3. 相关工作 2.3.3.1. LLMRank 论文：Large Language Models are Zero-Shot Rankers for Recommender Systems\n基于用户行为数据的推荐算法有两个问题：一是没有显式理解用户偏好，二是解决复杂推荐问题时，缺乏知识和推理能力。文章研究了使用PLM来推荐的若干问题。\n流程如下：\n序列化用户行为历史. 设计了3中不同的prompt：\nSequential prompting. 用原始用户行为顺序. Recency-focused prompting. 强调最近的行为. In-context learning. 引入其他用户的demonstration examples会引入噪声，因此使用当前用户的历史行为构造示例. LLM对候选排序. 将用户历史行为和候选商品放入prompt中，并加上排序instruction.\n结果后处理. 当item标题较短时，可以让LLM直接输出标题，否则可以输出标号。采用字符串匹配算法来匹配不能严格对齐的结果。LLM也有较小概率会生成不存在的item，大约3%.\n通过实验得到如下结论：\nLLM对历史行为顺序不敏感，按照时间顺序和随机打乱效果一样。但可以通过强调最近行为和ICL都能得到改善； 历史行为增多，LLM性能反而变差。这是因为LLM对历史行为顺序不敏感，较少行为反而能让LLM关注近期的行为； LLM排序时会考虑item流行度、文本相似度、历史行为等信息； 当候选集变大时，LLM排序能力也下降。可能和任务变难有关系； LLM受到Position bias影响，调整候选集顺序效果会有较大差异。可采用bootstrapping方式合并排序结果； 经过instruction tuning，排序性能更好。 2.3.3.2. TALLRec 论文：TALLRec: An Effective and Efficient Tuning Framework to Align Large Language Model with Recommendation\n直接利用PLM对候选商品打分可能会遇到以下问题：LLM要么只给出积极的预测(喜欢)，要么拒答。即使忽略拒答样本，剩余样本的AUC也只接近0.5，和随机猜类似。因此需要探索新的方法改善。\n本文采用了Llama-7B模型验证了在few-shot进行微调，其效果比传统模型明显好。\n2.4. 用户交互 在许多实际应用中，推荐系统通常是一个单轮交互过程，系统会随着时间的推移监控用户的行为（如点击和购买），然后在某些预定义的情况下呈现一组量身定制的相关item。这样的单轮交互在复杂场景中缺乏有效和多样化的方法来获取用户兴趣并检测用户当前的情况或需求。为此，大型语言模型的出现提供了一个有前途的替代方案，通过提供更积极和适应性更强的用户交互形式。LLM可以在与用户进行实时互动时，收集更多微妙的自然语言反馈，而不仅仅是被动地依赖用户过去的行为。\n一般来说，基于LLM的用户交互在推荐系统中通常表现为多轮对话，这涵盖了对话式推荐系统。在这样的对话过程中，LLM通过整合对话中的上下文和应用广泛的开放世界知识，提供了前所未有的理解用户兴趣和需求的丰富性。LLM可以通过引导用户当前的偏好、为项目建议提供解释或处理用户对建议的反馈来支持推荐系统进行高度相关和量身定制的推荐。换句话说，大型语言模型的引入使得推荐系统在用户交互方面更加可行和用户友好。具体来说，从交互内容的角度来看，基于LLM的用户交互方式可以分为：(1) 任务导向的用户交互，和 (2) 开放式用户交互。\n2.5. 流程控制器 LLM具有知识和推理能力，除了参与到推荐的某个环节外，还可以参与系统的流程控制，可能导致更具互动性和可解释性的推荐过程。例如Chat-REC利用ChatGPT来连接会话界面和传统推荐系统，其需要推断用户偏好，决定是否调用后端推荐API，并在向用户展示之前进一步修改（例如过滤和重新排序）返回的候选item。这些操作使LLM超越了上节的用户交互角色，并通过某些API调用和工具使用在多阶段推荐流水线中进行控制，以实现会话推荐系统。\n2.5.1. 相关工作 2.5.1.1. Chat-REC 论文：Chat-REC: Towards Interactive and Explainable LLMs-Augmented Recommender System\n传统推荐系统互动性差、可解释性差，也不能准确推荐新item。核心方法是连接推荐系统和LLM。\n2.5.1.2. RecLLM 论文：Leveraging Large Language Models in Conversational Recommender Systems\n会话推荐系统（CRS）通过允许用户通过实时多轮对话与系统交互，为用户提供了更高的透明度和控制权。最近，大型语言模型（LLMs）展现出了前所未有的自然对话能力，并将世界知识和常识推理融入语言理解中，解锁了这种范式的潜力。然而，在CRS中有效利用LLMs带来了新的技术挑战，包括正确理解和控制复杂的对话以及从外部信息源检索。这些问题因不断演变的大量物品语料库和缺乏对话数据进行训练而加剧。在本文中，提供了利用LLMs构建端到端大规模CRS的路线图。\n在推荐环境中特别具有挑战性的是如何在LLM和底层推荐引擎之间进行接口交互。一种方法是让LLM在充当对话代理的同时，也充当推荐引擎。然而，对于大规模推荐应用，物品语料库可能包含数百万或数十亿相互变化的物品，这使得LLM难以在其参数中记住语料库。另一种方法是LLM必须以某种方式连接到外部推荐引擎或数据库，传递相关的偏好信息。许多传统推荐系统采用两阶段管道，首先检索候选项目，然后对其进行排序。RecLLM 也遵循这种策略，增加了一个额外的特点，即排序器还会联合生成每个item被选择的推荐理由。\n第一阶段：召回\n采用了4种召回方法：\n双encoder模式：LLM为对话上下文生成embedding，item encoder生成item embedding，然后依据相似度做召回。这种从LLM内部提取embedding的方法的一个缺点是，它严重阻碍了我们以样本高效的方式学习检索模型的能力。 从头训练的双编码器模型需要大量的训练数据，以便将上下文塔的embedding约束在与物品塔embedding相同的子空间中。 LLM生成式推荐：LLM直接输出推荐的结果，推荐引擎负责在item pool中做匹配。在这种方法中，LLM直接以文本形式输出推荐的项目ID或标题。检索算法是对内容库中的项目进行精确或模糊匹配，推荐引擎在这简单匹配之外不再起其他作用。LLM必须通过其预训练和特定内容库的微调阶段的组合来学习输出这些ID/标题。假设我们的系统必须能够从固定的内容库返回推荐列表，这种方法最接近于让一个基于LLM的聊天机器人直接作为CRS工作。这个方法的缺点是，由于推荐引擎仅完成了微不足道的工作，LLM必须在其模型参数中记住整个内容库的信息。对于大型内容库，这在模型大小和所需训练数据方面可能是极其昂贵的，同时也使得难以在不重新训练LLM的情况下刷新内容库。 基于概念的搜索：让LLM基于对话生成一个概念list，推荐引擎将这个概念list编码成embedding，并和item embedding做召回。这种方法一个限制是概念列表通常是对话的粗略表示，类似于连续词袋方法，在词序和语言其他细微差别方面会有损失，这可能会对检索质量产生负面影响。 基于搜索API：LLM基于对话生成一条搜索的query，调用搜索引擎返回候选物品。检索质量受限于搜索查询能多大程度上适当地表示对话的全部上下文。 第二阶段：排序/解释\n给定items和上下文摘要作为输入，LLM排序器使用链式推理来评分项目。LLM生成的中间链式推理步骤作为某些项目最终包含或被排除在推荐清单之外的解释。这些解释可以内部用于调试，也可以展示给用户，通过将其作为输入包含在生成对话接口中的对话管理器中，或者通过后处理将其包含在推荐清单显示的视觉用户界面中的弹出框中。\n模型微调：\n在搜索API查找中，LLM处理会话历史记录并输出搜索查询，然后将其传递到黑箱搜索算法中。当使用这种架构时，损失不再是可微的，普通的监督学习不可行。相反，我们可以将设置重新框定为一个上下文bandit问题，其中LLM是一种策略，标签是奖励信号，黑箱搜索算法被视为环境。如果LLM编码器与其他模块共享，我们可以选择调优仅影响输出搜索查询这一任务的保护参数，或者调优也影响这些其他模块行为的共享参数。\n3. How to adapt LLM 3.1. 分类体系 根据是否微调/推断是否需要CRM两个维度将现有工作分为4个象限：\n3.2. 发展过程 3.3. 重要结论 3.3.1. 协同过滤知识非常重要 我们可以观察到第3象限和第1、2、4象限的研究工作之间存在明显的性能差异。即使第3象限的研究工作采用了大规模模型（如ChatGPT或GPT-4），并且配备了先进技术如用户行为检索和工具使用，其表现依然较差。这表明推荐系统是一个高度专业化的领域，要求大量的领域内协同知识。大型语言模型（LLM）无法从其通用预训练语料库中有效学习这种知识。因此，当我们将LLM应用于推荐系统时，必须涉及领域内协同知识以提高性能。通常有两种方法可以实现这一目标（对应于第1、2、4象限）：\n在训练阶段调优LLM，从数据中心的角度注入协同知识。 在推理阶段利用CRM，从模型中心的角度注入协同知识。 3.3.2. LLM擅长重排困难样本 尽管大型语言模型（LLM）在零样本/小样本学习方面通常表现较差，因为涉及的领域内协同知识较少，但研究发现，大型语言模型如ChatGPT更有可能在处理困难样本时表现出色。他们引入了过滤-再排序范式，该范式利用传统推荐系统中的预排序功能（例如在工业应用中的匹配或预排序阶段）来预先过滤掉那些容易的负例项，从而生成一组包含更难样本的候选项供LLM重新排序。这样，LLM的列表式再排序性能（尤其是类似ChatGPT的API）可以得到提升。这个发现对于工业应用具有指导意义，我们可以要求LLM仅处理困难样本，而将其他样本留给轻量级模型处理，以节省计算成本。\n4. 实际应用中的挑战 4.1. 训练效率 提升现代深度学习推荐系统性能的两个关键因素是：增加训练数据量和提高模型的更新频率。尽管调校大规模语言模型（LLM）可能提升性能，但也会带来巨大的时间和计算资源成本。因此，在实际应用中，需要确保适配LLM的训练效率。现有的研究主要通过参数高效微调（PEFT）方法解决内存使用问题，但在大规模场景中时间消耗仍然高。我们建议采用异步更新策略，将LLM用于特征工程时减少训练数据量和降低更新频率，同时保持CRM的完整数据和高频更新。这是基于LLM具有强大的归纳学习能力，通过少量监督可以产生广泛适用的结果。由此，LLM为CRM提供领域内知识，CRM则作为LLM的频繁更新适配器。\n4.2. 推理延迟 在线推荐系统通常是实时服务，对时间非常敏感，各个阶段（如匹配、排序、重排序）需在几十毫秒内完成。大规模语言模型（LLM）在推理阶段的参与会增加推理延迟。预计算和缓存LLM的输出或中间表示是确保低延迟的一种常见策略。例如，M6-Rec提出了分段后期交互策略，先预计算和缓存细粒度文本特征的编码表示，再在推荐请求到达时进行后期交互。其他方法如UniSRec和VQ-Rec则直接缓存语言模型生成的嵌入。此策略对静态的物品信息有效，但对动态的用户信息来说效果不佳，因此需要找到合适的缓存频率来平衡性能和计算成本。\n另外，可以通过模型压缩技术（如蒸馏、剪枝和量化）来减少模型大小以提高推理效率。例如，CTRL和FLIP通过对比学习将LLM的语义知识蒸馏到CRM中，从而在保持低延迟推理的同时改进推荐性能。这些策略通常涉及模型性能和推理延迟之间的权衡。另一种选择是将LLM用于特征工程阶段，预存其输出，从而在推理时减少额外负担。此外，还可以将LLM应用于推理延迟要求较宽松的场景，如对话推荐系统。\n4.3. 领域长文本建模 在适配大规模语言模型（LLM）时，需通过提示模板构建领域内的文本输入，并在前面必要时插入适当的指令和示范。然而，真实世界的推荐系统通常需要更长的用户历史、更大的候选集和更多特征，这可能导致LLM输入的长文本带来两大挑战：\n过长的文本输入会导致内存效率低下的问题（经典变压器的空间复杂度为O(L²)，其中L是词元数量），甚至可能超出上下文窗口的限制，导致部分信息丢失和次优的输出。 即使输入长度不超过上下文窗口，LLM在完全理解和推理推荐数据上也可能存在问题。研究表明，LLM处理长文本时困难重重，尤其是在扩展用户历史或候选集时，即使总词元数远未达到上下文窗口限制。这可能是因为领域内长文本与LLM预训练语料的分布差异很大。 因此，研究如何在提示工程中适当地筛选、选择和安排文本信息作为LLM的输入，以及如何指导或调校LLM更好地适应这些领域内长文本的分布非常重要。此外，在自然语言处理领域，有一系列工作提出了解决上下文窗口限制的方法（如滑动窗口、记忆机制），这些方法可以在推荐系统中考虑应用。此外，最近的研究提出结合CRM的潜在表示来压缩LLM的个性化输入提示，以缓解长文本问题。例如，CoLLM和E4SRec通过线性投影层将每个用户行为的文本描述替换为CRM嵌入表中的潜在向量，从而大大减少长用户序列的词元数量。受前缀调优的启发，ClickPrompt将CRM的样本级最终表示转化为LLM的层级提示，从而更容易从提示模板中去除不必要的特征。\n4.4. ID索引化和建模 在推荐系统中，存在一种本质上不包含语义信息的纯ID特征（如用户ID、物品ID）。如果将这些ID特征包含在提示文本中，它们的分词对语言模型而言实际上是无意义的。许多研究倾向于直接放弃这些ID特征，以通过自然语言界面实现统一的跨领域推荐，因为这些ID通常在不同领域之间不共享。然而，有些研究指出，尽管牺牲跨领域的泛化能力，ID特征可以大大提升推荐性能。因此，是否保留ID特征仍然是一个未解决的问题，将研究分为两种方向。\n**一方面，我们可以保留ID特征以牺牲跨领域泛化能力换取更好的领域内推荐性能。**P5及其变体在提示模板中保留ID特征，并设计了全词嵌入层，为相同ID特征的词元分配相同的全词嵌入，类似于位置嵌入的方式。基于此，Hua等进一步探索了各种物品ID索引策略以确保相似物品的ID由相似的子词元组成。RecFormer和UniSRec则在提示文本中省略物品ID，但在底部嵌入层或顶部投影层引入额外的ID嵌入。其他研究则寻求整合传统推荐模型中的ID嵌入，从而使LLM的输入提示不包含纯ID特征。总之，这条研究线路上，研究人员应专注于通过精心设计的ID索引与建模策略来将LLM与ID特征关联起来。\n**另一方面，我们可以放弃ID特征，以通过自然语言界面实现统一的跨领域推荐。**保持一个统一的模型来服务多个领域是非常有前景的，尤其是在涉及大规模语言模型时。为了在放弃ID特征的情况下实现与保留ID特征的类似性能，研究人员可以探讨隐式引入ID特征的方法，例如应用对比学习来对齐语义和协同知识，从而避免涉及LLM的ID特征。\n5. 参考文献 A Survey on Large Language Models for Recommendation How Can Recommender Systems Benefit from Large Language Models: A Survey Large Language Model Augmented Narrative Driven Recommendations TagGPT: Large Language Models are Zero-shot Multimodal Taggers Exploring the Upper Limits of Text-Based Collaborative Filtering Using Large Language Models: Discoveries and Insights Learning Vector-Quantized Item Representation for Transferable Sequential Recommenders Large Language Models are Zero-Shot Rankers for Recommender Systems TALLRec: An Effective and Efficient Tuning Framework to Align Large Language Model with Recommendation Chat-REC: Towards Interactive and Explainable LLMs-Augmented Recommender System Leveraging Large Language Models in Conversational Recommender Systems ","wordCount":"10675","inLanguage":"en","datePublished":"2025-05-01T00:58:22+08:00","dateModified":"2025-05-01T00:58:22+08:00","author":[{"@type":"Person","name":"Huaipeng Zhao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hpzhao.github.io/posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Huaipeng's Blog","logo":{"@type":"ImageObject","url":"https://hpzhao.github.io/img/logo.gif"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hpzhao.github.io/ accesskey=h title="Huaipeng's Blog (Alt + H)">Huaipeng's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hpzhao.github.io/ title=Posts><span>Posts</span></a></li><li><a href=https://hpzhao.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://hpzhao.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://hpzhao.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://hpzhao.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hpzhao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hpzhao.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">大模型在推荐领域的应用</h1><div class=post-meta><span title='2025-05-01 00:58:22 +0800 +0800'>2025-05-01</span>&nbsp;·&nbsp;<span>22 min</span>&nbsp;·&nbsp;<span>Huaipeng Zhao</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e7%9b%b8%e5%85%b3%e8%83%8c%e6%99%af aria-label="1. 相关背景">1. 相关背景</a><ul><li><a href=#11-%e7%8e%b0%e4%bb%a3%e6%8e%a8%e8%8d%90%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84 aria-label="1.1. 现代推荐系统架构">1.1. 现代推荐系统架构</a></li><li><a href=#12-%e5%88%86%e7%b1%bb%e8%8c%83%e5%bc%8f aria-label="1.2. 分类范式">1.2. 分类范式</a></li></ul></li><li><a href=#2-where-to-adapt-llm aria-label="2. Where to adapt LLM">2. Where to adapt LLM</a><ul><li><a href=#21-%e7%89%b9%e5%be%81%e5%b7%a5%e7%a8%8b aria-label="2.1. 特征工程">2.1. 特征工程</a><ul><li><a href=#211-%e7%89%b9%e5%be%81%e5%a2%9e%e5%bc%ba aria-label="2.1.1. 特征增强">2.1.1. 特征增强</a></li><li><a href=#212-%e6%a0%b7%e6%9c%ac%e7%94%9f%e6%88%90 aria-label="2.1.2. 样本生成">2.1.2. 样本生成</a></li><li><a href=#213-%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c aria-label="2.1.3. 相关工作">2.1.3. 相关工作</a><ul><li><a href=#2131-mint aria-label="2.1.3.1. MINT">2.1.3.1. MINT</a></li><li><a href=#2132-taggpt aria-label="2.1.3.2. TagGPT">2.1.3.2. TagGPT</a></li></ul></li></ul></li><li><a href=#22-%e7%89%b9%e5%be%81%e7%bc%96%e7%a0%81 aria-label="2.2. 特征编码">2.2. 特征编码</a><ul><li><a href=#221-%e8%a1%a8%e7%a4%ba%e5%a2%9e%e5%bc%ba aria-label="2.2.1. 表示增强">2.2.1. 表示增强</a></li><li><a href=#222-%e7%bb%9f%e4%b8%80%e8%b7%a8%e9%a2%86%e5%9f%9f%e6%8e%a8%e8%8d%90 aria-label="2.2.2. 统一跨领域推荐">2.2.2. 统一跨领域推荐</a></li><li><a href=#223-%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c aria-label="2.2.3. 相关工作">2.2.3. 相关工作</a><ul><li><a href=#2231-llm%e6%8e%a2%e7%b4%a2text-cf%e4%b8%8a%e9%99%90 aria-label="2.2.3.1. LLM探索Text CF上限">2.2.3.1. LLM探索Text CF上限</a></li><li><a href=#2232-vq-rec aria-label="2.2.3.2. VQ-Rec">2.2.3.2. VQ-Rec</a></li></ul></li></ul></li><li><a href=#23-%e6%89%93%e5%88%86%e6%8e%92%e5%ba%8f%e5%87%bd%e6%95%b0 aria-label="2.3. 打分/排序函数">2.3. 打分/排序函数</a><ul><li><a href=#231-item%e6%89%93%e5%88%86%e4%bb%bb%e5%8a%a1 aria-label="2.3.1. item打分任务">2.3.1. item打分任务</a></li><li><a href=#232-item%e7%94%9f%e6%88%90%e4%bb%bb%e5%8a%a1 aria-label="2.3.2. item生成任务">2.3.2. item生成任务</a><ul><li><a href=#2321-%e5%bc%80%e6%94%be%e9%9b%86item%e7%94%9f%e6%88%90 aria-label="2.3.2.1. 开放集item生成">2.3.2.1. 开放集item生成</a></li><li><a href=#2322-%e9%97%ad%e9%9b%86item%e7%94%9f%e6%88%90 aria-label="2.3.2.2. 闭集item生成">2.3.2.2. 闭集item生成</a></li><li><a href=#2323-%e6%b7%b7%e5%90%88%e4%bb%bb%e5%8a%a1 aria-label="2.3.2.3. 混合任务">2.3.2.3. 混合任务</a></li></ul></li><li><a href=#233-%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c aria-label="2.3.3. 相关工作">2.3.3. 相关工作</a><ul><li><a href=#2331-llmrank aria-label="2.3.3.1. LLMRank">2.3.3.1. LLMRank</a></li><li><a href=#2332-tallrec aria-label="2.3.3.2. TALLRec">2.3.3.2. TALLRec</a></li></ul></li></ul></li><li><a href=#24-%e7%94%a8%e6%88%b7%e4%ba%a4%e4%ba%92 aria-label="2.4. 用户交互">2.4. 用户交互</a></li><li><a href=#25-%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label="2.5. 流程控制器">2.5. 流程控制器</a><ul><li><a href=#251-%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c aria-label="2.5.1. 相关工作">2.5.1. 相关工作</a><ul><li><a href=#2511-chat-rec aria-label="2.5.1.1. Chat-REC">2.5.1.1. Chat-REC</a></li><li><a href=#2512-recllm aria-label="2.5.1.2. RecLLM">2.5.1.2. RecLLM</a></li></ul></li></ul></li></ul></li><li><a href=#3-how-to-adapt-llm aria-label="3. How to adapt LLM">3. How to adapt LLM</a><ul><li><a href=#31-%e5%88%86%e7%b1%bb%e4%bd%93%e7%b3%bb aria-label="3.1. 分类体系">3.1. 分类体系</a></li><li><a href=# aria-label></a></li><li><a href=#32-%e5%8f%91%e5%b1%95%e8%bf%87%e7%a8%8b aria-label="3.2. 发展过程">3.2. 发展过程</a></li><li><a href=#33-%e9%87%8d%e8%a6%81%e7%bb%93%e8%ae%ba aria-label="3.3. 重要结论">3.3. 重要结论</a><ul><li><a href=#331-%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4%e7%9f%a5%e8%af%86%e9%9d%9e%e5%b8%b8%e9%87%8d%e8%a6%81 aria-label="3.3.1. 协同过滤知识非常重要">3.3.1. 协同过滤知识非常重要</a></li><li><a href=#332-llm%e6%93%85%e9%95%bf%e9%87%8d%e6%8e%92%e5%9b%b0%e9%9a%be%e6%a0%b7%e6%9c%ac aria-label="3.3.2. LLM擅长重排困难样本">3.3.2. LLM擅长重排困难样本</a></li></ul></li></ul></li><li><a href=#4-%e5%ae%9e%e9%99%85%e5%ba%94%e7%94%a8%e4%b8%ad%e7%9a%84%e6%8c%91%e6%88%98 aria-label="4. 实际应用中的挑战">4. 实际应用中的挑战</a><ul><li><a href=#41-%e8%ae%ad%e7%bb%83%e6%95%88%e7%8e%87 aria-label="4.1. 训练效率">4.1. 训练效率</a></li><li><a href=#42-%e6%8e%a8%e7%90%86%e5%bb%b6%e8%bf%9f aria-label="4.2. 推理延迟">4.2. 推理延迟</a></li><li><a href=#43-%e9%a2%86%e5%9f%9f%e9%95%bf%e6%96%87%e6%9c%ac%e5%bb%ba%e6%a8%a1 aria-label="4.3. 领域长文本建模">4.3. 领域长文本建模</a></li><li><a href=#44-id%e7%b4%a2%e5%bc%95%e5%8c%96%e5%92%8c%e5%bb%ba%e6%a8%a1 aria-label="4.4. ID索引化和建模">4.4. ID索引化和建模</a></li></ul></li><li><a href=#5-%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label="5. 参考文献">5. 参考文献</a></li></ul></div></details></div><div class=post-content><p>本文范式取自参考文献[3]，内容贴近工业界推荐系统。在遵循其分类范式基础上，补充了一些学术届和工业界的相关工作.</p><h1 id=1-相关背景>1. 相关背景<a hidden class=anchor aria-hidden=true href=#1-相关背景>#</a></h1><h2 id=11-现代推荐系统架构>1.1. 现代推荐系统架构<a hidden class=anchor aria-hidden=true href=#11-现代推荐系统架构>#</a></h2><p>推荐系统的核心任务就是在给定一个用户$u \in \mathbb{U}$和上下文$C$的情况下，推荐一批排好序的items:$[i_k]^N_{k=1}$，$\mathcal{i}k \in \mathscr{I}$即：</p>$$ \bigl[i_k\bigr]_{k=1}^N \leftarrow \mathbf{RS}(u, c, \mathscr{I}),\; u \in \mathcal{U},\; i_k \in \mathscr{I} $$<p>上下文是个比较重要的变量，比如同一用户在首猜和在LazFlash推荐的结果差异很大。</p><p>推荐系统大致可分为数据收集、特征工程、特征编码、打分/排序、用户交互和流程控制器几个环节。除了数据收集外，其他环节大模型都可以参与其中。</p><div align=center><img src=/img/1721299900457-e67781b4-17c1-4e2e-aa9e-1cc95a332f40.png alt=img width=100%></div><h2 id=12-分类范式>1.2. 分类范式<a hidden class=anchor aria-hidden=true href=#12-分类范式>#</a></h2><p>LLM在推荐系统的应用可以从两个视角来看：<strong>Where</strong>和<strong>How</strong>。Where是指LLM在推荐系统哪个环节应用，How是指LLM在推荐系统的应用方式(训练和推理)。<strong>CRM</strong>表示<strong>C</strong>onventional <strong>R</strong>ecommendation <strong>M</strong>odel。</p><div align=center><img src=/img/1721300356446-b5764110-467a-4d56-9281-7cabe496777d.png alt=img width=100%></div><h1 id=2-where-to-adapt-llm>2. Where to adapt LLM<a hidden class=anchor aria-hidden=true href=#2-where-to-adapt-llm>#</a></h1><h2 id=21-特征工程>2.1. 特征工程<a hidden class=anchor aria-hidden=true href=#21-特征工程>#</a></h2><h3 id=211-特征增强>2.1.1. 特征增强<a hidden class=anchor aria-hidden=true href=#211-特征增强>#</a></h3><p>由于具有强大的推理能力和开放世界知识，LLM（大型语言模型）常被视为灵活的知识库。因此，它能够提供辅助特征，以更好地进行用户偏好建模和项目内容理解。CUP 采用 ChatGPT 根据用户评论文本总结每个用户的兴趣，通过关键词压缩用户画像数据，使其可以被小规模语言模型（如 BERT）编码。</p><h3 id=212-样本生成>2.1.2. 样本生成<a hidden class=anchor aria-hidden=true href=#212-样本生成>#</a></h3><p>除了特征增强，LLM 还用于生成合成样本，丰富训练数据集，提高模型预测质量。Zhang 等人进一步尝试结合多个大型语言模型作为代理，以模拟更真实推荐场景中的细粒度用户交流和交互。</p><h3 id=213-相关工作>2.1.3. 相关工作<a hidden class=anchor aria-hidden=true href=#213-相关工作>#</a></h3><h4 id=2131-mint>2.1.3.1. MINT<a hidden class=anchor aria-hidden=true href=#2131-mint>#</a></h4><p>论文：<a href=https://arxiv.org/pdf/2306.02250>Large Language Model Augmented Narrative Driven Recommendations</a></p><p><strong>MINT</strong>表示Data aug<strong>M</strong>entation with <strong>IN</strong>teraction narra<strong>T</strong>ives。</p><p>叙事驱动推荐（Narrative-driven recommendation，<strong>NDR</strong>）是一个信息访问问题，其中用户通过详细描述自己的偏好和情境来请求推荐，例如，旅行者在描述他们的喜好/厌恶和旅行情况时请求推荐景点。随着基于自然语言的对话接口在搜索和推荐系统中的崛起，这些请求变得越来越重要。然而，NDR缺乏丰富的用于模型训练的训练数据，当前的平台通常不支持这些请求。作者利用大模型扩充数据来训练NDR模型。核心思路是利用现有的user-item交互数据，用大模型将用户兴趣总结成陈述性文本。</p><div align=center><img src=/img/1721303362776-67676c55-e2d0-41f7-a906-bc7094e76a66.png alt=img width=100%></div><h4 id=2132-taggpt>2.1.3.2. TagGPT<a hidden class=anchor aria-hidden=true href=#2132-taggpt>#</a></h4><p>论文：<a href=https://arxiv.org/pdf/2304.03022>TagGPT: Large Language Models are Zero-shot Multimodal Taggers</a></p><p>标签在现代互联网时代的各种应用中（如搜索引擎和推荐系统）对多媒体内容的有效分发起着关键作用。本文提出了TagGPT，一个能够以完全零样本方式进行标签提取和多模态标签化的全自动系统。我们的核心启示是，通过精细的提示工程，LLMs能够根据多模态数据的文本线索（例如OCR, ASR, 标题等）提取和推理出合适的标签。具体来说，为了自动构建一个高质量的标签集，以反映特定应用的用户意图和兴趣，TagGPT通过提示LLMs从一系列的原始数据中预测大规模的候选标签，并通过频率和语义进行筛选。</p><div align=center><img src=/img/1721304426488-ddfa7b5f-bbb9-414d-92e8-e8bc9c2adbd1.png alt=img width=100%></div><p>抽取的标签也做了进一步后处理，频率太高的没有区分性，频率太低的没有代表性。另外也对相似度过高的tag进行合并。</p><p>下图是抽取结果的一个示例：</p><div align=center><img src=/img/1721304613789-dfd6ecf2-3599-43cb-adbb-85401513ca30.png alt=img width=100%></div><h2 id=22-特征编码>2.2. 特征编码<a hidden class=anchor aria-hidden=true href=#22-特征编码>#</a></h2><p>利用LLM作为辅助文本特征编码器，从而获得两大主要好处：（1）进一步为后续的神经推荐模型提供丰富的user/item表示，其中包含语义信息；（2）通过自然语言作为桥梁，实现跨领域推荐，在这种情况下，ID特征字段可能不共享。</p><h3 id=221-表示增强>2.2.1. 表示增强<a hidden class=anchor aria-hidden=true href=#221-表示增强>#</a></h3><p>在一些文本特征丰富的场景(例如item有标题、详细描述等)，LLM被用于特征编码器。LLM4ARec利用GPT2从用户画像和评论中提取个性化的方面术语和潜在向量，以更好地辅助推荐。在一些特殊情况下，LLM编码的语义表示不会直接用作后续评分/排序函数的输入。相反，它通过量化被转换为一系列离散的token，以适应需要离散输入的评分/排序函数（例如，生成推荐）。</p><h3 id=222-统一跨领域推荐>2.2.2. 统一跨领域推荐<a hidden class=anchor aria-hidden=true href=#222-统一跨领域推荐>#</a></h3><p>除了改善user/item表示之外，LLM作为特征编码器还可以实现迁移学习和跨领域推荐，自然语言在其中起到了对齐不同领域异构信息的桥梁作用。ZESRec应用BERT将物品描述转换为通用的语义表示，用于零样本推荐。在UniSRec中，物品表示通过一个固定的BERT模型和一个轻量级的MoE增强网络进行学习，以实现跨领域序列推荐。</p><h3 id=223-相关工作>2.2.3. 相关工作<a hidden class=anchor aria-hidden=true href=#223-相关工作>#</a></h3><h4 id=2231-llm探索text-cf上限>2.2.3.1. LLM探索Text CF上限<a hidden class=anchor aria-hidden=true href=#2231-llm探索text-cf上限>#</a></h4><p>论文：<a href=https://arxiv.org/abs/2305.11700>Exploring the Upper Limits of Text-Based Collaborative Filtering Using Large Language Models: Discoveries and Insights</a></p><p>现存TCF系统大都采用参数规模较小的BERT系架构编码item，本文探索利用LLM提升TCF上限。针对下面几个问题有初步结论。</p><ul><li><p><strong>Q1：TCF范式达到性能瓶颈了么？</strong></p></li><li><ul><li>还未看到瓶颈，随着参数规模增大，性能一直在提升。</li></ul></li></ul><div align=center><img src=/img/1721549104457-08aa4f27-f2d3-40dc-af37-de54fb77b685.png alt=img width=100%></div><ul><li><p><strong>Q2：175B的LLM能得到通用表征么？</strong></p></li><li><ul><li>在推荐任务上fine-tune的LLM性能有明显提升，说明现在的LLM生成的Embedding远不够通用</li></ul></li></ul><div align=center><img src=/img/1721549278570-2a878cf2-5a91-4be2-9e44-1f5fcd012b80.png alt=img width=100%></div><ul><li><p><strong>Q3：基于175B参数LLM的TCF能轻易替代IDCF么？</strong></p></li><li><ul><li>175B的TCF在某些场景下和IDCF性能可比，但远谈不上能够替代，尤其是考虑到IDCF的高效性。</li></ul></li></ul><div align=center><img src=/img/1721549427223-87d4e4da-9f23-4bbf-a107-e485544c0d0e.png alt=img width=100%></div><h4 id=2232-vq-rec>2.2.3.2. VQ-Rec<a hidden class=anchor aria-hidden=true href=#2232-vq-rec>#</a></h4><p>论文：<a href=https://arxiv.org/abs/2210.12316>Learning Vector-Quantized Item Representation for Transferable Sequential Recommenders</a></p><p>基于IDCF方法的推荐模型可迁移性差，因此出现大量工作研究利用item的文本来表示item，在跨领域迁移时取得了不错的结果。然而item和其文本绑定太紧密可能会造成潜在问题，例如过分强调文本特征而忽略交互特征，两个文本相似的item其表现可能差异很大。因此本文提出VQ技术建模item表示，让其既具备文本特征，又能通过协同过滤更新，减少对推荐系统影响。</p><p>VQ-Rec分为三步：</p><ol><li><strong>VQ Item表征</strong>. 利用PLM对item的文本进行编码得到item embedding，然后通过PQ将item embedding映射为D个code，再给每个code分配一个可学习embedding。item最终由这D个code池化后的向量表示。</li><li><strong>对比学习预训练</strong>. 为提高跨领域能力，提高方法通用性，在多领域推荐数据上预训练code emb和Transformer参数，采用对比学习方式训练。为让负样本更有意义，摈弃了batch内随机采样，采用了两种方案构造hard负样本：一是半混合负样本，二是混合领域采样。</li><li><strong>跨领域微调</strong>. 由于不同领域文本分布差异较大，因此对item->code映射重新适配，并微调code emb，fix住Transformer参数。</li></ol><div align=center><img src=/img/1721572792522-c29e7c17-4d69-4af8-a419-ddbeb64a980a.png alt=img width=100%></div><h2 id=23-打分排序函数>2.3. 打分/排序函数<a hidden class=anchor aria-hidden=true href=#23-打分排序函数>#</a></h2><p>打分/排序的目标一般和推荐系统的最终目标息息相关。根据LLM所解决的不同任务，分为三类：1）item打分任务 2）item生成任务 3）混合任务</p><h3 id=231-item打分任务>2.3.1. item打分任务<a hidden class=anchor aria-hidden=true href=#231-item打分任务>#</a></h3><p>在item打分任务中，LLM扮演pointwise打分函数$F(u,i)$。候选商品最终的序由排序分决定：</p><div align=center><img src=/img/1721616759211-ec833086-43ab-40f8-8901-6b797afd792c.png alt=img style=zoom:50%></div><p>Pre-filter为item预选阶段，主要是为了减小候选集规模，一般包含检索和粗排阶段。</p><p>LLM产生token的一般流程如下：</p><div align=center><img src=/img/1721617226979-5bdd00d0-6352-4e5c-adf2-b94ffccddfd0.png alt=img style=zoom:50%></div><p>其中$\hat{t}$为离散token。但打分任务一般要求打分函数产生有意义的实数，例如CTR任务要求输出分数为$\hat{y} \in [0,1]$，打分预测任务要求$\hat{y} \in [0,5]$。针对这一问题，通常有三种主要解决方法：</p><p><strong>第一种方法</strong>摈弃LLM解码层，采用单塔结构，直接将隐层$h$映射为分数：</p><div align=center><img src=/img/1721617829168-059fd659-7719-4de9-a464-930d5d095fe3.png alt=img style=zoom:50%></div><p>输入提示需要包含用户和item信息，以支持基于隐层的偏好估计。E4SRec通过预先学习的用户和物品ID嵌入来构建个性化提示，以实现精确的偏好估计。CER加强了推荐内容与其自然语言解释之间的一致性，以提高评分预测的性能。</p><p><strong>第二种方法</strong>也摈弃了LLM解码层，采用双塔结构：</p><div align=center><img src=/img/1721618743293-7fc75ec0-626c-4a2e-af86-2e17b12b1f36.png alt=img style=zoom:50%></div><p>在这类工作中，一般重点是设计不同的辅助结构以使用LLM增强双侧信息。通过采用编码器-解码器LLM，TASTE首先将每个用户行为编码成一个软提示向量，然后利用解码器从软提示序列中提取用户偏好。</p><p><strong>第三种方法</strong>保留了LLM解码层，将打分问题转化成二元问题，即给定U和I，U是否喜欢I，基于候选答案概率归一化得到最终分数：</p><div align=center><img src=/img/1721619327887-601b6a33-228e-478e-8fdf-e6d4ce769ca6.png alt=img style=zoom:50%></div><h3 id=232-item生成任务>2.3.2. item生成任务<a hidden class=anchor aria-hidden=true href=#232-item生成任务>#</a></h3><p>在item生成任务中，LLM作为生成函数$F(u)$直接生成最终item排序列表，仅需要一次前向计算。一般而言，item生成任务高度依赖LLM的内在推理能力，其过程可表示为：</p><div align=center><img src=/img/1721619966757-c289c40c-8587-46f3-ba4a-a123d4abfa7c.png alt=img style=zoom:50%></div><p>根据是否提供候选item，其方案可分为两类：1）开放集item生成 2）闭集item生成。</p><h4 id=2321-开放集item生成>2.3.2.1. 开放集item生成<a hidden class=anchor aria-hidden=true href=#2321-开放集item生成>#</a></h4><p>LLM直接根据user profile和历史行为生成用户偏好的排序item列表。由于在输入提示中并未提供候选item，因此可能会产生幻觉问题，生成的item无法准确匹配item池中的item。因此除了设计输入提示模版和微调算法之外，还需要在item生成后进行匹配后处理操作 ，以克服幻觉问题。这一过程描述如下：</p><div align=center><img src=/img/1721626991790-835736f5-2f8f-40dd-a7ec-fbfc722ff76f.png alt=img style=zoom:50%></div><p>其中$\hat{i_k}$是LLM生成的item，$i_k$为item池中真实存在的item，Match为匹配函数。</p><p>LANCER采用知识增强的前缀微调来进行生成基础，并进一步应用余弦相似度将生成item文本的编码表示与通用item池进行匹配。Di Palma 等人利用ChatGPT进行用户兴趣建模和下一个item标题生成，并使用Damerau-Levenshtein 距离进行item匹配。</p><p>除了以文本方式生成item外，另一研究方向聚焦于<strong>将语言空间与基于ID的推荐空间对齐，从而使LLM可以直接生成item ID</strong>。例如，Hua 等人探索了更好的item索引方法（如顺序索引、协作索引），以提升此类索引生成任务的性能。LightLM设计了一种轻量级 LLM，结合了精心设计的用户和item索引，并使用约束束搜索进行开放集合item ID 的生成。此外，LLaRA在 LLM 的输入提示中采用了一种新颖的混合方法，将传统推荐系统中的基于 ID 的item嵌入与文本item特征相结合。其他关于开放集合item生成的典型工作包括：GenRec，TransRec，LC-Rec，ControlRec和POD。</p><h4 id=2322-闭集item生成>2.3.2.2. 闭集item生成<a hidden class=anchor aria-hidden=true href=#2322-闭集item生成>#</a></h4><p>LLM需要根据给定的候选item集合排序。候选item一般由pre-filter挑选得到。受限于LLM上下文窗口长度，候选item数量通常最多设置成20个，一般是重排阶段。过程形式化为：</p><div align=center><img src=/img/1721628048526-43cd6f8f-5c86-45a0-8069-b04a0d75fe26.png alt=img style=zoom:50%></div><p>例如，LlamaRec 采用 LRURec作为检索器，并在预筛选的项目上微调 LLaMA2 以进行列表排名。DRDT通过多轮迭代反思对给定候选项目进行排名，以逐步优化排列表。</p><p>相比之下，开放集生成任务通常会遭遇生成幻觉问题，即生成的item可能无法与通用item池中的确切item匹配。因此，后续的生成匹配功能是非常必要的，这增加了推理推理成本甚至可能影响最终的推荐性能，尤其是在item文本与大型语言模型的语言分布差异很大的场景中。与此相反，封闭集生成任务使用轻量级检索模型作为预筛选器，提供一组明确的候选item，因此大型语言模型可以缓解幻觉问题。然而，将候选item引入大型语言模型的输入提示中会导致其他问题。首先，由于上下文窗口的限制，大型语言模型无法处理大量的候选item（通常少于20个），最终的推荐性能可能会受到检索模型（即预筛选器）的限制。此外，Ma 等和 Hou 等发现，<strong>在提示中打乱候选item的顺序会影响排名结果，导致不稳定的推荐结果</strong>。上述封闭集生成任务的问题本质上源于输入提示中存在候选item集，这在开放集生成任务中可以得到很好地解决。总的来说，我们可以观察到，开放集和封闭集生成任务在各自的优缺点上是互补的。因此，在实际应用中选择哪种任务实际上取决于我们在现实场景中遇到的具体情况和问题。</p><h4 id=2323-混合任务>2.3.2.3. 混合任务<a hidden class=anchor aria-hidden=true href=#2323-混合任务>#</a></h4><p>在混合任务中，大型语言模型以多任务的方式运作，通过统一的语言接口处理item打分和生成任务。支持这种混合功能的基础是大型语言模型本质上是多任务学习器。例如，P5、M6-Rec和InstructRec通过不同的提示模板调整编码器-解码器模型，以更好地对齐一系列推荐任务，包括项目评分和生成任务。</p><h3 id=233-相关工作>2.3.3. 相关工作<a hidden class=anchor aria-hidden=true href=#233-相关工作>#</a></h3><h4 id=2331-llmrank>2.3.3.1. LLMRank<a hidden class=anchor aria-hidden=true href=#2331-llmrank>#</a></h4><p>论文：<a href=https://arxiv.org/pdf/2305.08845>Large Language Models are Zero-Shot Rankers for Recommender Systems</a></p><p>基于用户行为数据的推荐算法有两个问题：一是没有显式理解用户偏好，二是解决复杂推荐问题时，缺乏知识和推理能力。文章研究了使用PLM来推荐的若干问题。</p><div align=center><img src=/img/1721630254643-2affc650-1eda-4834-9bef-33d76957002d.png alt=img width=100%></div><p>流程如下：</p><ul><li><p><strong>序列化用户行为历史</strong>. 设计了3中不同的prompt：</p></li><li><ul><li><strong>Sequential prompting</strong>. 用原始用户行为顺序.<ul><li><strong>Recency-focused prompting</strong>. 强调最近的行为.</li><li><strong>In-context learning</strong>. 引入其他用户的demonstration examples会引入噪声，因此使用当前用户的历史行为构造示例.</li></ul></li></ul></li><li><p><strong>LLM对候选排序</strong>. 将用户历史行为和候选商品放入prompt中，并加上排序instruction.</p></li><li><p><strong>结果后处理</strong>. 当item标题较短时，可以让LLM直接输出标题，否则可以输出标号。采用字符串匹配算法来匹配不能严格对齐的结果。LLM也有较小概率会生成不存在的item，大约3%.</p></li></ul><p>通过实验得到如下结论：</p><ol><li>LLM对历史行为顺序不敏感，按照时间顺序和随机打乱效果一样。但可以通过强调最近行为和ICL都能得到改善；</li><li>历史行为增多，LLM性能反而变差。这是因为LLM对历史行为顺序不敏感，较少行为反而能让LLM关注近期的行为；</li><li>LLM排序时会考虑item流行度、文本相似度、历史行为等信息；</li><li>当候选集变大时，LLM排序能力也下降。可能和任务变难有关系；</li><li>LLM受到Position bias影响，调整候选集顺序效果会有较大差异。可采用bootstrapping方式合并排序结果；</li><li>经过instruction tuning，排序性能更好。</li></ol><h4 id=2332-tallrec>2.3.3.2. TALLRec<a hidden class=anchor aria-hidden=true href=#2332-tallrec>#</a></h4><p>论文：<a href=https://arxiv.org/abs/2305.00447>TALLRec: An Effective and Efficient Tuning Framework to Align Large Language Model with Recommendation</a></p><p>直接利用PLM对候选商品打分可能会遇到以下问题：LLM要么只给出积极的预测(喜欢)，要么拒答。即使忽略拒答样本，剩余样本的AUC也只接近0.5，和随机猜类似。因此需要探索新的方法改善。</p><div align=center><img src=/img/1721633374093-846f1610-7815-4f10-b7e9-3cbf6585fe63.png alt=img width=100%></div><p>本文采用了Llama-7B模型验证了在few-shot进行微调，其效果比传统模型明显好。</p><div align=center><img src=/img/1721633665168-3b78d700-68e8-4ae2-b0a0-83b499a38100.png alt=img width=100%></div><div align=center><img src=/img/1721633681987-83b4ad94-75b5-4b30-8fde-91dfbfce39be.png alt=img width=100%></div><h2 id=24-用户交互>2.4. 用户交互<a hidden class=anchor aria-hidden=true href=#24-用户交互>#</a></h2><p>在许多实际应用中，推荐系统通常是一个单轮交互过程，系统会随着时间的推移监控用户的行为（如点击和购买），然后在某些预定义的情况下呈现一组量身定制的相关item。这样的单轮交互在复杂场景中缺乏有效和多样化的方法来获取用户兴趣并检测用户当前的情况或需求。为此，大型语言模型的出现提供了一个有前途的替代方案，通过提供更积极和适应性更强的用户交互形式。LLM可以在与用户进行实时互动时，收集更多微妙的自然语言反馈，而不仅仅是被动地依赖用户过去的行为。</p><p>一般来说，基于LLM的用户交互在推荐系统中通常表现为多轮对话，这涵盖了<strong>对话式推荐系统</strong>。在这样的对话过程中，LLM通过整合对话中的上下文和应用广泛的开放世界知识，提供了前所未有的理解用户兴趣和需求的丰富性。LLM可以通过引导用户当前的偏好、为项目建议提供解释或处理用户对建议的反馈来支持推荐系统进行高度相关和量身定制的推荐。换句话说，<strong>大型语言模型的引入使得推荐系统在用户交互方面更加可行和用户友好</strong>。具体来说，从交互内容的角度来看，基于LLM的用户交互方式可以分为：(1) 任务导向的用户交互，和 (2) 开放式用户交互。</p><h2 id=25-流程控制器>2.5. 流程控制器<a hidden class=anchor aria-hidden=true href=#25-流程控制器>#</a></h2><p>LLM具有知识和推理能力，除了参与到推荐的某个环节外，还可以参与系统的流程控制，可能导致更具<strong>互动性</strong>和<strong>可解释性</strong>的推荐过程。例如Chat-REC利用ChatGPT来连接会话界面和传统推荐系统，其需要推断用户偏好，决定是否调用后端推荐API，并在向用户展示之前进一步修改（例如过滤和重新排序）返回的候选item。这些操作使LLM超越了上节的用户交互角色，并通过某些API调用和工具使用在多阶段推荐流水线中进行控制，以实现会话推荐系统。</p><h3 id=251-相关工作>2.5.1. 相关工作<a hidden class=anchor aria-hidden=true href=#251-相关工作>#</a></h3><h4 id=2511-chat-rec>2.5.1.1. Chat-REC<a hidden class=anchor aria-hidden=true href=#2511-chat-rec>#</a></h4><p>论文：<a href=https://arxiv.org/abs/2303.14524>Chat-REC: Towards Interactive and Explainable LLMs-Augmented Recommender System</a></p><p>传统推荐系统互动性差、可解释性差，也不能准确推荐新item。核心方法是连接推荐系统和LLM。</p><div align=center><img src=/img/1721636076494-b01c3858-ad76-43df-9ab3-237c7d92cf06.png alt=img width=100%></div><h4 id=2512-recllm>2.5.1.2. RecLLM<a hidden class=anchor aria-hidden=true href=#2512-recllm>#</a></h4><p>论文：<a href=https://arxiv.org/pdf/2305.07961>Leveraging Large Language Models in Conversational Recommender Systems</a></p><p>会话推荐系统（CRS）通过允许用户通过实时多轮对话与系统交互，为用户提供了更高的透明度和控制权。最近，大型语言模型（LLMs）展现出了前所未有的自然对话能力，并将世界知识和常识推理融入语言理解中，解锁了这种范式的潜力。然而，在CRS中有效利用LLMs带来了新的技术挑战，包括正确理解和控制复杂的对话以及从外部信息源检索。这些问题因不断演变的大量物品语料库和缺乏对话数据进行训练而加剧。在本文中，提供了利用LLMs构建端到端大规模CRS的路线图。</p><p>在推荐环境中特别具有挑战性的是如何在LLM和底层推荐引擎之间进行接口交互。<strong>一种方法是让LLM在充当对话代理的同时，也充当推荐引擎</strong>。然而，对于大规模推荐应用，物品语料库可能包含数百万或数十亿相互变化的物品，这使得LLM难以在其参数中记住语料库。<strong>另一种方法是LLM必须以某种方式连接到外部推荐引擎或数据库，传递相关的偏好信息</strong>。许多传统推荐系统采用两阶段管道，首先检索候选项目，然后对其进行排序。RecLLM 也遵循这种策略，增加了一个额外的特点，即排序器还会联合生成每个item被选择的推荐理由。</p><div align=center><img src=/img/1721639291503-7bd9bc27-0477-47de-8c8b-e1dbf2f18e6c.png alt=img width=100%></div><p><strong>第一阶段：召回</strong></p><div align=center><img src=/img/1721637658680-d07a0987-f36b-4acf-a158-526a48904e98.png alt=img width=100%></div><p>采用了4种召回方法：</p><ol><li><strong>双encoder模式</strong>：LLM为对话上下文生成embedding，item encoder生成item embedding，然后依据相似度做召回。这种从LLM内部提取embedding的方法的一个缺点是，它严重阻碍了我们以样本高效的方式学习检索模型的能力。 从头训练的双编码器模型需要大量的训练数据，以便将上下文塔的embedding约束在与物品塔embedding相同的子空间中。</li><li><strong>LLM生成式推荐</strong>：LLM直接输出推荐的结果，推荐引擎负责在item pool中做匹配。在这种方法中，LLM直接以文本形式输出推荐的项目ID或标题。检索算法是对内容库中的项目进行精确或模糊匹配，推荐引擎在这简单匹配之外不再起其他作用。LLM必须通过其预训练和特定内容库的微调阶段的组合来学习输出这些ID/标题。假设我们的系统必须能够从固定的内容库返回推荐列表，这种方法最接近于让一个基于LLM的聊天机器人直接作为CRS工作。这个方法的缺点是，由于推荐引擎仅完成了微不足道的工作，<strong>LLM必须在其模型参数中记住整个内容库的信息。对于大型内容库，这在模型大小和所需训练数据方面可能是极其昂贵的，同时也使得难以在不重新训练LLM的情况下刷新内容库</strong>。</li><li><strong>基于概念的搜索</strong>：让LLM基于对话生成一个概念list，推荐引擎将这个概念list编码成embedding，并和item embedding做召回。这种方法一个限制是概念列表通常是对话的粗略表示，类似于连续词袋方法，在词序和语言其他细微差别方面会有损失，这可能会对检索质量产生负面影响。</li><li><strong>基于搜索API</strong>：LLM基于对话生成一条搜索的query，调用搜索引擎返回候选物品。检索质量受限于搜索查询能多大程度上适当地表示对话的全部上下文。</li></ol><p><strong>第二阶段：排序/解释</strong></p><p>给定items和上下文摘要作为输入，LLM排序器使用链式推理来评分项目。LLM生成的中间链式推理步骤作为某些项目最终包含或被排除在推荐清单之外的解释。这些解释可以内部用于调试，也可以展示给用户，通过将其作为输入包含在生成对话接口中的对话管理器中，或者通过后处理将其包含在推荐清单显示的视觉用户界面中的弹出框中。</p><p><strong>模型微调</strong>：</p><p>在搜索API查找中，LLM处理会话历史记录并输出搜索查询，然后将其传递到黑箱搜索算法中。当使用这种架构时，损失不再是可微的，普通的监督学习不可行。相反，我们可以将设置重新框定为一个上下文bandit问题，其中LLM是一种策略，标签是奖励信号，黑箱搜索算法被视为环境。如果LLM编码器与其他模块共享，我们可以选择调优仅影响输出搜索查询这一任务的保护参数，或者调优也影响这些其他模块行为的共享参数。</p><div align=center><img src=/img/1721639840527-ac221d18-1104-4ecd-92d7-ed458fc7753e.png alt=img width=100%></div><h1 id=3-how-to-adapt-llm>3. How to adapt LLM<a hidden class=anchor aria-hidden=true href=#3-how-to-adapt-llm>#</a></h1><h2 id=31-分类体系>3.1. 分类体系<a hidden class=anchor aria-hidden=true href=#31-分类体系>#</a></h2><p>根据是否微调/推断是否需要CRM两个维度将现有工作分为4个象限：</p><h2><div align=center><img src=/img/1721640056720-c954c18d-509a-4c24-be22-7049f42a1771.png alt=img width=100%></div></h2><h2 id=32-发展过程>3.2. 发展过程<a hidden class=anchor aria-hidden=true href=#32-发展过程>#</a></h2><div align=center><img src=/img/1721640280984-ff6b8447-b65a-4bd3-8084-b8c5c93777a8.png alt=img width=100%></div><h2 id=33-重要结论>3.3. 重要结论<a hidden class=anchor aria-hidden=true href=#33-重要结论>#</a></h2><h3 id=331-协同过滤知识非常重要>3.3.1. 协同过滤知识非常重要<a hidden class=anchor aria-hidden=true href=#331-协同过滤知识非常重要>#</a></h3><p>我们可以观察到第3象限和第1、2、4象限的研究工作之间存在明显的性能差异。即使第3象限的研究工作采用了大规模模型（如ChatGPT或GPT-4），并且配备了先进技术如用户行为检索和工具使用，其表现依然较差。这表明推荐系统是一个高度专业化的领域，要求大量的领域内协同知识。大型语言模型（LLM）无法从其通用预训练语料库中有效学习这种知识。因此，当我们将LLM应用于推荐系统时，必须涉及领域内协同知识以提高性能。通常有两种方法可以实现这一目标（对应于第1、2、4象限）：</p><ul><li>在训练阶段调优LLM，从数据中心的角度注入协同知识。</li><li>在推理阶段利用CRM，从模型中心的角度注入协同知识。</li></ul><h3 id=332-llm擅长重排困难样本>3.3.2. LLM擅长重排困难样本<a hidden class=anchor aria-hidden=true href=#332-llm擅长重排困难样本>#</a></h3><p>尽管大型语言模型（LLM）在零样本/小样本学习方面通常表现较差，因为涉及的领域内协同知识较少，但研究发现，大型语言模型如ChatGPT更有可能在处理困难样本时表现出色。他们引入了过滤-再排序范式，该范式利用传统推荐系统中的预排序功能（例如在工业应用中的匹配或预排序阶段）来预先过滤掉那些容易的负例项，从而生成一组包含更难样本的候选项供LLM重新排序。这样，LLM的列表式再排序性能（尤其是类似ChatGPT的API）可以得到提升。这个发现对于工业应用具有指导意义，我们可以要求LLM仅处理困难样本，而将其他样本留给轻量级模型处理，以节省计算成本。</p><h1 id=4-实际应用中的挑战>4. 实际应用中的挑战<a hidden class=anchor aria-hidden=true href=#4-实际应用中的挑战>#</a></h1><h2 id=41-训练效率>4.1. 训练效率<a hidden class=anchor aria-hidden=true href=#41-训练效率>#</a></h2><p>提升现代深度学习推荐系统性能的两个关键因素是：增加训练数据量和提高模型的更新频率。尽管调校大规模语言模型（LLM）可能提升性能，但也会带来巨大的时间和计算资源成本。因此，在实际应用中，需要确保适配LLM的训练效率。现有的研究主要通过参数高效微调（PEFT）方法解决内存使用问题，但在大规模场景中时间消耗仍然高。我们建议采用异步更新策略，将LLM用于特征工程时减少训练数据量和降低更新频率，同时保持CRM的完整数据和高频更新。这是基于LLM具有强大的归纳学习能力，通过少量监督可以产生广泛适用的结果。由此，LLM为CRM提供领域内知识，CRM则作为LLM的频繁更新适配器。</p><h2 id=42-推理延迟>4.2. 推理延迟<a hidden class=anchor aria-hidden=true href=#42-推理延迟>#</a></h2><p>在线推荐系统通常是实时服务，对时间非常敏感，各个阶段（如匹配、排序、重排序）需在几十毫秒内完成。大规模语言模型（LLM）在推理阶段的参与会增加推理延迟。预计算和缓存LLM的输出或中间表示是确保低延迟的一种常见策略。例如，M6-Rec提出了分段后期交互策略，先预计算和缓存细粒度文本特征的编码表示，再在推荐请求到达时进行后期交互。其他方法如UniSRec和VQ-Rec则直接缓存语言模型生成的嵌入。此策略对静态的物品信息有效，但对动态的用户信息来说效果不佳，因此需要找到合适的缓存频率来平衡性能和计算成本。</p><p>另外，可以通过模型压缩技术（如蒸馏、剪枝和量化）来减少模型大小以提高推理效率。例如，CTRL和FLIP通过对比学习将LLM的语义知识蒸馏到CRM中，从而在保持低延迟推理的同时改进推荐性能。这些策略通常涉及模型性能和推理延迟之间的权衡。另一种选择是将LLM用于特征工程阶段，预存其输出，从而在推理时减少额外负担。此外，还可以将LLM应用于推理延迟要求较宽松的场景，如对话推荐系统。</p><h2 id=43-领域长文本建模>4.3. 领域长文本建模<a hidden class=anchor aria-hidden=true href=#43-领域长文本建模>#</a></h2><p>在适配大规模语言模型（LLM）时，需通过提示模板构建领域内的文本输入，并在前面必要时插入适当的指令和示范。然而，真实世界的推荐系统通常需要更长的用户历史、更大的候选集和更多特征，这可能导致LLM输入的长文本带来两大挑战：</p><ol><li>过长的文本输入会导致内存效率低下的问题（经典变压器的空间复杂度为O(L²)，其中L是词元数量），甚至可能超出上下文窗口的限制，导致部分信息丢失和次优的输出。</li><li>即使输入长度不超过上下文窗口，LLM在完全理解和推理推荐数据上也可能存在问题。研究表明，LLM处理长文本时困难重重，尤其是在扩展用户历史或候选集时，即使总词元数远未达到上下文窗口限制。这可能是因为领域内长文本与LLM预训练语料的分布差异很大。</li></ol><p>因此，研究如何在提示工程中适当地筛选、选择和安排文本信息作为LLM的输入，以及如何指导或调校LLM更好地适应这些领域内长文本的分布非常重要。此外，在自然语言处理领域，有一系列工作提出了解决上下文窗口限制的方法（如滑动窗口、记忆机制），这些方法可以在推荐系统中考虑应用。此外，最近的研究提出结合CRM的潜在表示来压缩LLM的个性化输入提示，以缓解长文本问题。例如，CoLLM和E4SRec通过线性投影层将每个用户行为的文本描述替换为CRM嵌入表中的潜在向量，从而大大减少长用户序列的词元数量。受前缀调优的启发，ClickPrompt将CRM的样本级最终表示转化为LLM的层级提示，从而更容易从提示模板中去除不必要的特征。</p><h2 id=44-id索引化和建模>4.4. ID索引化和建模<a hidden class=anchor aria-hidden=true href=#44-id索引化和建模>#</a></h2><p>在推荐系统中，存在一种本质上不包含语义信息的纯ID特征（如用户ID、物品ID）。如果将这些ID特征包含在提示文本中，它们的分词对语言模型而言实际上是无意义的。许多研究倾向于直接放弃这些ID特征，以通过自然语言界面实现统一的跨领域推荐，因为这些ID通常在不同领域之间不共享。然而，有些研究指出，尽管牺牲跨领域的泛化能力，ID特征可以大大提升推荐性能。因此，是否保留ID特征仍然是一个未解决的问题，将研究分为两种方向。</p><p>**一方面，我们可以保留ID特征以牺牲跨领域泛化能力换取更好的领域内推荐性能。**P5及其变体在提示模板中保留ID特征，并设计了全词嵌入层，为相同ID特征的词元分配相同的全词嵌入，类似于位置嵌入的方式。基于此，Hua等进一步探索了各种物品ID索引策略以确保相似物品的ID由相似的子词元组成。RecFormer和UniSRec则在提示文本中省略物品ID，但在底部嵌入层或顶部投影层引入额外的ID嵌入。其他研究则寻求整合传统推荐模型中的ID嵌入，从而使LLM的输入提示不包含纯ID特征。总之，这条研究线路上，研究人员应专注于通过精心设计的ID索引与建模策略来将LLM与ID特征关联起来。</p><p>**另一方面，我们可以放弃ID特征，以通过自然语言界面实现统一的跨领域推荐。**保持一个统一的模型来服务多个领域是非常有前景的，尤其是在涉及大规模语言模型时。为了在放弃ID特征的情况下实现与保留ID特征的类似性能，研究人员可以探讨隐式引入ID特征的方法，例如应用对比学习来对齐语义和协同知识，从而避免涉及LLM的ID特征。</p><h1 id=5-参考文献>5. 参考文献<a hidden class=anchor aria-hidden=true href=#5-参考文献>#</a></h1><ul><li><a href=https://arxiv.org/abs/2305.19860>A Survey on Large Language Models for Recommendation</a></li><li><a href=https://arxiv.org/pdf/2306.05817v5>How Can Recommender Systems Benefit from Large Language Models: A Survey</a></li><li><a href=https://arxiv.org/pdf/2306.02250>Large Language Model Augmented Narrative Driven Recommendations</a></li><li><a href=https://arxiv.org/pdf/2304.03022>TagGPT: Large Language Models are Zero-shot Multimodal Taggers</a></li><li><a href=https://arxiv.org/abs/2305.11700>Exploring the Upper Limits of Text-Based Collaborative Filtering Using Large Language Models: Discoveries and Insights</a></li><li><a href=https://arxiv.org/abs/2210.12316>Learning Vector-Quantized Item Representation for Transferable Sequential Recommenders</a></li><li><a href=https://arxiv.org/pdf/2305.08845>Large Language Models are Zero-Shot Rankers for Recommender Systems</a></li><li><a href=https://arxiv.org/abs/2305.00447>TALLRec: An Effective and Efficient Tuning Framework to Align Large Language Model with Recommendation</a></li><li><a href=https://arxiv.org/abs/2303.14524>Chat-REC: Towards Interactive and Explainable LLMs-Augmented Recommender System</a></li><li><a href=https://arxiv.org/pdf/2305.07961>Leveraging Large Language Models in Conversational Recommender Systems</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://hpzhao.github.io/posts/deepseek-r1%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/><span class=title>Next »</span><br><span>DeepSeek R1论文解读</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://hpzhao.github.io/>Huaipeng's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>